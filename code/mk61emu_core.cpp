/* 
 * This file is part of the MK61S distribution (https://gitlab.com/vitasam/mk61s).
 * Copyright (c) 2020- vitasam.
 * 
 * Based on emu145 code from F.Lazarev:
 * https://github.com/fixelsan/emu145
 * 
 * This program is free software: you can redistribute it and/or modify  
 * it under the terms of the GNU General Public License as published by  
 * the Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
//#include "Arduino.h"
#include "mk61emu_core.h"
#include "debug.h"
#include "config.h"
#include "tools.hpp"
#include "rust_types.h"

typedef struct {  // Структору ПЗУ для одной микросхемы комплекта К145ИК(02,03,06)
    microinstruction_t microinstructions[68]; // микрокоманды
    instruction_t instructions[256];          // команды
} IK13_ROM;

typedef struct { // ПЗУ микрокода, микропрограмм для всего комплекта К145ИК(02,03,06) МК61
    IK13_ROM IK1302;
    IK13_ROM IK1303;
    IK13_ROM IK1306;
} mk61ROM_t;

typedef struct { // Структура микросхемы К145IИК303 
    uint8_t *pM;
    uint8_t R[IK13_MTICK_COUNT];
    uint8_t ST[IK13_MTICK_COUNT];

    io_t AMK, MOD;
    io_t S, S1, L, T, P;

    //uint16_t uI_hi;     // Instruction HI word
    uint8_t  flag_FC;
    uint8_t *pAND_AMK;  // Precalc offset from microprograms for signal_I 0..26
    uint8_t *pAND_AMK1; // Precalc offset from microprograms for signal_I 27..35
    uint16_t key_x, key_xm, key_y, comma;
}  IK1303;

typedef struct { // Структура микросхемы К145IИК306 
    //uint16_t uI_hi;  // Instruction HI word
    uint32_t AMK;

    uint32_t  L, S, S1, P, T, MOD, flag_FC;

    uint8_t   R[IK13_MTICK_COUNT];
    uint8_t   ST[IK13_MTICK_COUNT];

    uint8_t*  pAND_AMK1; // Precalc offset from microprograms for signal_I 27..35
    uint8_t*  pAND_AMK;
    uint8_t*  pM;
}  IK1306;

void IK1302_Tick(mtick_t signal_I, usize J_signal_I);
void IK1302_Clear(void);

void IK1303_Tick(mtick_t signal_I, usize J_signal_I);
void IK1303_Clear(void);

void IK1306_Tick(mtick_t signal_I, usize J_signal_I);
void IK1306_Clear(void);

/* Кольцо ДОЗУ - последовательно соединенная память комплектов микросхем К145ИК(02,03,06) в МК61 */
u8 ringM[SIZE_RING_M/*252+252+42+42+42+42*/];
const u8* END_ring_M = &ringM[SIZE_RING_M/*252+252+42+42+42+42*/];

const bool sergey_anvarov_hack_enable = true;

MK61Emu m_emu;

static const char default_symbols[16] = {
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', 'L', 'C', 'r', 'E', ' '
};

#include <array>
#if IS_CORTEX_M4() //__ARM_ARCH == 7
  #warning("Hardware mul/div present!")
#else
  #warning("Hardware mul/div unavaliable! Instantiate multiply by 9 and divide by 3 as constant table!")
  constexpr static const std::array<uint8_t, 256> div3_table = []() {
    std::array<uint8_t, 256> _{};
    for (auto i=0; i<256; i++) _[i]=i/3;
    return _;
  }();

  constexpr static const std::array<uint8_t, 256> mul9_table = []() {
    std::array<uint8_t, 256> _{};
    for (auto i=0; i<256; i++) _[i]=i*9;
    return _;
  }();
#endif

/*static std::array<uint8_t, 42+41> mod42_table = []() {
  std::array<uint8_t, 42+41> _{};
  for (auto i=0; i<42+41; i++) _[i]=i%42;
  return _;
}();*/
/*
static std::array<uint8_t, 256> __attribute__ ((aligned (16))) mod42_table = []() {
  std::array<uint8_t, 256> _{};
  for (auto i=0; i<256; i++) _[i]=i%42;
  return _;
}();
*/
static u8 __attribute__ ((aligned (16))) mod42_table[42+41];

#define DIV3(v)         (((v)*171)>>9)  //(div3_table[v]) 
//#define DIV3(v)       (((v)*171)>>9)
//#define DIV3(v)       ((v)/3)         //udiv M3/M4 

#if IS_CORTEX_M4() //__ARM_ARCH == 7
  #define MUL9(v)       ((v)*9)
#else
  #define MUL9(v)       (mul9_table[v])
//#define MUL9(v)       ((v)*9)
//#define MUL9(v)       ( ((v)+((v)<<3)) &0xff )
#endif

#define MOD42(v)       (mod42_table[v])
//#define MOD42(v)  ( ((v) %42) &0xff )

static const mk61ROM_t ROM = {
        IK1302: {
                microinstructions: {
                        0x0000000, 0x0800001, 0x0A00820, 0x0040020, // 1
                        0x0A03120, 0x0203081, 0x0A00181, 0x0803800,
                        0x0818001, 0x0800400, 0x0A00089, 0x0A03C20,
                        0x0800820, 0x0080020, 0x0800120, 0x1400020,
                        0x0800081, 0x0210801, 0x0040000, 0x0058001,
                        0x0808001, 0x0A03081, 0x0A01081, 0x0A01181,
                        0x0040090, 0x0800401, 0x0A00081, 0x0040001,
                        0x0800801, 0x1000000, 0x0800100, 0x1200801,
                        0x0013C01, 0x0800008, 0x0A00088, 0x0010200,
                        0x0800040, 0x0800280, 0x1801200, 0x1000208, // 10
                        0x0080001, 0x0A00082, 0x0A01008, 0x1000001,
                        0x0A00808, 0x0900001, 0x8010004, 0x0080820,
                        0x0800002, 0x0140002, 0x0008000, 0x0A00090,
                        0x0A00220, 0x0801001, 0x1203200, 0x4800001,
                        0x0011801, 0x1008001, 0x0A04020, 0x4800801,
                        0x0840801, 0x0840020, 0x0013081, 0x0010801,
                        0x0818180, 0x0800180, 0x0A00081, 0x0800001  //17
                },
                instructions: {
                        0x00204E4E, 0x00117360, 0x00114840, 0x01040240, // 1
                        0x00164040, 0x001B3240, 0x00064640, 0x015B4013,
                        0x00D93130, 0x00001040, 0x01A52014, 0x00000000,
                        0x00000000, 0x00000000, 0x00000000, 0x00C12040,
                        0x00D0536D, 0x00517740, 0x00B43130, 0x00B22223,
                        0x00C15340, 0x00FD2040, 0x002D1D1D, 0x0008403B,
                        0x00092140, 0x00094061, 0x000A2140, 0x00082140,
                        0x000D7076, 0x010D400D, 0x000A403B, 0x00056D40,
                        0x00100259, 0x010B1340, 0x00242044, 0x010B7840,
                        0x00064002, 0x01FF2008, 0x0008565A, 0x0126403F, // 10
                        0x016C400D, 0x00C12077, 0x00517740, 0x00517740,
                        0x00083240, 0x010C400D, 0x01FF200A, 0x010B3568,
                        0x00117B5A, 0x0021206D, 0x01222034, 0x01015C5B,
                        0x01D03454, 0x00005E5D, 0x010E400D, 0x010E0044,
                        0x00F44E40, 0x009A206D, 0x00F44E5A, 0x00000000,
                        0x00000000, 0x00000000, 0x00000000, 0x00C11D1D,
                        0x00063333, 0x010B403B, 0x01344043, 0x00096A6A,
                        0x000A4443, 0x00792120, 0x01D32047, 0x00081E1E,
                        0x01AF1140, 0x00AB1D1D, 0x0039324C, 0x000B324C,
                        0x0008326D, 0x000D404C, 0x00854D40, 0x00134040, // 20
                        0x0009404C, 0x006D7770, 0x006D7240, 0x01001640,
                        0x00A54C7E, 0x00F44E40, 0x01536900, 0x000A580E,
                        0x003C5262, 0x0005716D, 0x013C4013, 0x00104070,
                        0x00056F6D, 0x00A62070, 0x00106F40, 0x01056F40,
                        0x001F3E3D, 0x0028595A, 0x001E2223, 0x00064B40,
                        0x00524A40, 0x00692120, 0x001B4940, 0x00093240,
                        0x011F0140, 0x00154840, 0x00062423, 0x00062423,
                        0x01057340, 0x015E400D, 0x00095828, 0x00092223,
                        0x00992F40, 0x00982F40, 0x00622040, 0x005D5820,
                        0x00740F40, 0x00B81C20, 0x00D05373, 0x005B205C, // 30
                        0x006D2062, 0x0133200A, 0x010B7D62, 0x00A52120,
                        0x01054072, 0x01494013, 0x01040540, 0x00217362,
                        0x013D6A40, 0x00067840, 0x01AB6C6D, 0x01332014,
                        0x000E7C6C, 0x00050B3F, 0x00C15340, 0x00950853,
                        0x00E0417A, 0x00E04240, 0x00532120, 0x00365562,
                        0x008F1E20, 0x013D1740, 0x004C2120, 0x0170406A,
                        0x00C05340, 0x00061D1D, 0x00814545, 0x00063333,
                        0x00061E1E, 0x00091E1E, 0x00900720, 0x01514078,
                        0x00081D1D, 0x01622206, 0x001E4545, 0x00114060,
                        0x000B2E40, 0x000F2D40, 0x010E1F40, 0x000D7677, // 40
                        0x00D33C40, 0x01D32032, 0x00116E60, 0x011D3440,
                        0x00FF7440, 0x00073240, 0x001B430A, 0x01D32047,
                        0x00113434, 0x001E6E40, 0x00D33C40, 0x00937540,
                        0x00D01E20, 0x00043277, 0x00CA4020, 0x00107F54,
                        0x00212068, 0x000B7840, 0x017C400C, 0x00056F6D,
                        0x01470C40, 0x01716B62, 0x006B2120, 0x00332120,
                        0x006D204C, 0x00E67362, 0x010D0940, 0x00062423,
                        0x001A3A3A, 0x018F406F, 0x0151334C, 0x010D1716,
                        0x01D35340, 0x00D24061, 0x00CA6554, 0x00104064,
                        0x00512223, 0x00782120, 0x00263130, 0x001E3434, // 50
                        0x00193838, 0x00183939, 0x000D6654, 0x010D7A40,
                        0x010E1740, 0x00057340, 0x00B86140, 0x00045263,
                        0x00122773, 0x008F5373, 0x002E5150, 0x0151404C,
                        0x001E3737, 0x00894E40, 0x001E3636, 0x006D563D,
                        0x00E07A41, 0x00E12973, 0x00082640, 0x00062540,
                        0x00D87967, 0x0005565A, 0x0005286C, 0x00762041,
                        0x00952040, 0x008F1D1D, 0x01D35340, 0x008F2040,
                        0x00CC4F4F, 0x00114060, 0x00054040, 0x001E3434,
                        0x01047340, 0x011E3434, 0x00C62C2B, 0x00C53130,
                        0x003E1D1D, 0x01041740, 0x001E3535, 0x00D35353, // 60
                        0x00DE4077, 0x00E24057, 0x00064E68, 0x01E53812,
                        0x00D84067, 0x00064069, 0x000A402A, 0x00EF202A,
                        0x01015C5B, 0x00090F40, 0x00005E5D, 0x010B3613,
                        0x00144740, 0x01176806, 0x000A5A5A, 0x01D3200D  // 64
                }
        },
        IK1303: {
                microinstructions: {
                    0x0000000, 0x0800001, 0x0040020, 0x1440090, // 1
                        0x0A00081, 0x1000000, 0x1400020, 0x0800008,
                        0x0A03180, 0x1002200, 0x0800400, 0x1418001,
                        0x0080020, 0x0841020, 0x0203100, 0x0203088,
                        0x0A00820, 0x0800120, 0x08001C0, 0x0810081,
                        0x0A00089, 0x0800401, 0x0A010A0, 0x0A01081,
                        0x0818001, 0x1A00220, 0x0201100, 0x0203420,
                        0x0008000, 0x0801020, 0x0201420, 0x0801190,
                        0x0040000, 0x0080820, 0x0800002, 0x0140002,
                        0x0800100, 0x0A03C20, 0x0A00808, 0x0A01008, // 10
                        0x0200540, 0x0601209, 0x0083100, 0x0A03081,
                        0x8800004, 0x0058001, 0x1001280, 0x1008001,
                        0x1200209, 0x4018001, 0x0040002, 0x1000001,
                        0x0010200, 0x0800840, 0x0A01181, 0x4018801,
                        0x0A10181, 0x0800801, 0x0040001, 0x0011190,
                        0x0858001, 0x0040020, 0x3200209, 0x08000C0,
                        0x4000020, 0x0600081, 0x1000000, 0x1000180  // 17
                },
                instructions: {
                        0x00386050, 0x005B3F3E, 0x000F5970, 0x00152470, // 1
                        0x000C3D50, 0x0011312F, 0x005B4544, 0x00165050,
                        0x000C3404, 0x005B3F3E, 0x00D40450, 0x00162424,
                        0x000C4962, 0x01FB5250, 0x000D4924, 0x01BB2222,
                        0x00155050, 0x010F5247, 0x00182525, 0x00080505,
                        0x000E041E, 0x00123433, 0x007F6425, 0x007F0D25,
                        0x01650950, 0x01176553, 0x007E2432, 0x00087150,
                        0x007E2455, 0x00135076, 0x00085977, 0x005B4544,
                        0x000C2E26, 0x00310D2E, 0x00100E35, 0x00316B47,
                        0x01381250, 0x0011302E, 0x01385F50, 0x00050250, // 10
                        0x011C0101, 0x00195050, 0x00382C2C, 0x016F2222,
                        0x013A2222, 0x002F6B56, 0x00093D6C, 0x00F04D50,
                        0x000C1750, 0x00074A50, 0x01B45047, 0x003C2020,
                        0x01AA2B6A, 0x00123432, 0x001D4933, 0x0113500C,
                        0x00052556, 0x00087C50, 0x01130000, 0x00142B2B,
                        0x004A1D50, 0x006E5756, 0x00496050, 0x00E57D58,
                        0x011E5D22, 0x01F35F50, 0x00EA0505, 0x001C7A50,
                        0x01080B50, 0x0054244B, 0x000C4050, 0x002A2121,
                        0x00135C5C, 0x000A4650, 0x00152504, 0x009D2B60,
                        0x00064350, 0x00192020, 0x00292C2C, 0x01235C50, // 20
                        0x006D3C3C, 0x0031017D, 0x00092D2D, 0x004E2D2D,
                        0x01596A7E, 0x00E3396E, 0x006E3654, 0x016E6E47,
                        0x00534950, 0x00EE2062, 0x0016226E, 0x00660525,
                        0x00135C5C, 0x000A4241, 0x00383B3B, 0x000C7277,
                        0x00360404, 0x00042020, 0x00100A2E, 0x00155050,
                        0x00532404, 0x0004642B, 0x01843C47, 0x01A35047,
                        0x01847250, 0x015C112F, 0x00080434, 0x00152F23,
                        0x00080505, 0x00906047, 0x0113150C, 0x006D2224,
                        0x00747250, 0x000C632B, 0x00AD672B, 0x000A612E,
                        0x01B97463, 0x00417374, 0x00BD0658, 0x00EA2450, // 30
                        0x00087166, 0x01BD3950, 0x001A2E50, 0x00BD6047,
                        0x00175079, 0x005E6035, 0x000A3847, 0x01067F47,
                        0x008C5251, 0x0013612E, 0x0087602E, 0x005B3F3E,
                        0x00DC2121, 0x00177374, 0x00182525, 0x00286050,
                        0x00064F4E, 0x000C5251, 0x006E2926, 0x008F602F,
                        0x008C502A, 0x00172928, 0x00814F4E, 0x003F534B,
                        0x000F075B, 0x00082525, 0x01E85047, 0x00790505,
                        0x00152F23, 0x0017506A, 0x00095047, 0x00082525,
                        0x00E63A62, 0x00DA0B47, 0x01174150, 0x00182525,
                        0x00090450, 0x01175B50, 0x00094850, 0x001B2F50, // 40
                        0x00806047, 0x000A3720, 0x0010382F, 0x002C0505,
                        0x009B5021, 0x00160505, 0x01ED3A50, 0x00040505,
                        0x00082525, 0x01080F50, 0x01B35047, 0x000D3D4C,
                        0x00180404, 0x01C03A50, 0x00E20421, 0x00287B50,
                        0x00097F26, 0x0013612E, 0x01B6112F, 0x00322425,
                        0x01B81847, 0x00BA714B, 0x00182450, 0x00080505,
                        0x00182525, 0x004F1D24, 0x00736F5C, 0x00A67569,
                        0x00AD2726, 0x01BE5022, 0x000A5E04, 0x00173A62,
                        0x00CB752E, 0x00B11E25, 0x00CB0953, 0x00085068,
                        0x002B2020, 0x01984150, 0x00C77C04, 0x00DA0950, // 50
                        0x00160404, 0x00F56040, 0x00DE0450, 0x01CB1160,
                        0x00CF4950, 0x000A4747, 0x001F210B, 0x00145050,
                        0x01171050, 0x00052075, 0x001D3D37, 0x00365555,
                        0x00130101, 0x01D57424, 0x00D66047, 0x01C47850,
                        0x004D2C2C, 0x01174150, 0x00174847, 0x00C90350,
                        0x000A2760, 0x0019502E, 0x00D72C2C, 0x01174850,
                        0x006C224B, 0x000A495B, 0x00100E35, 0x00312104,
                        0x01C00850, 0x00115A2F, 0x00EA0505, 0x00080574,
                        0x00152F23, 0x005C6050, 0x01C94122, 0x01A42222,
                        0x00DF2847, 0x00C9202E, 0x00A76047, 0x0117502F, // 60
                        0x002E2020, 0x01205048, 0x00F8606D, 0x002D604C,
                        0x00443A62, 0x000D3D2E, 0x015C3950, 0x01625022,
                        0x006E136E, 0x0031602E, 0x01085D1A, 0x010F6F50,
                        0x0017506A, 0x00FB5020, 0x000A3C47, 0x00174D50  // 64
                }
        },
        IK1306: {
                microinstructions: {
                        0x0000000, 0x0800008, 0x0040020, 0x0800001, // 1
                        0x0800021, 0x0080020, 0x0A00028, 0x0040100,
                        0x4000100, 0x0010100, 0x0A00101, 0x0201089,
                        0x0213201, 0x0800004, 0x0800800, 0x0800820,
                        0x0200088, 0x4810002, 0x0A00820, 0x0800400,
                        0x0801000, 0x0100000, 0x8800004, 0x0008000,
                        0x1400020, 0x0800005, 0x4000020, 0x0A00180,
                        0x0100000, 0x4000001, 0x8241004, 0x0400000,
                        0x0080001, 0x0040001, 0x0212801, 0x0200808,
                        0x0800000, 0x0010020, 0x0A00808, 0x0040090, // 10
                        0x0A01008, 0x0800401, 0x0A00081, 0x0A01081,
                        0x0803400, 0x0A01001, 0x0A11801, 0x0011001,
                        0x0A10801, 0x0213801, 0x0098001, 0x0818001,
                        0x0800420, 0x0880090, 0x0203C08, 0x0200809,
                        0x0A00089, 0x0203090, 0x0840090, 0x0810002,
                        0x0210801, 0x0210081, 0x0010000, 0x0200090,
                        0x0210081, 0x0212801, 0x0A01020, 0x0A01020  // 17
                },
                instructions: {
                        0x0070000, 0x0060040, 0x0076A2F, 0x00B4C00, // 1
                        0x0090000, 0x00B4D00, 0x0090000, 0x0055300,
                        0x0090000, 0x00B5400, 0x0090000, 0x0054600,
                        0x0061000, 0x00B4800, 0x0065657, 0x0057300,
                        0x0090000, 0x0075655, 0x0071700, 0x0060040,
                        0x0070000, 0x0070000, 0x0074444, 0x00C4545,
                        0x0280058, 0x0682825, 0x08A0000, 0x0280059,
                        0x0800058, 0x0800059, 0x04D5F5F, 0x0FB2F22,
                        0x0FB2F21, 0x0F80000, 0x0FB2F20, 0x0940000,
                        0x0B80059, 0x0B80058, 0x0830000, 0x03D4343, // 10
                        0x0075E5E, 0x0075B00, 0x0695900, 0x007002B,
                        0x0070028, 0x0070003, 0x0070028, 0x0070052,
                        0x0070015, 0x00C0037, 0x00F5C00, 0x0075C01,
                        0x0075D5D, 0x007285F, 0x0DC585B, 0x00C005C,
                        0x0680000, 0x0070A0A, 0x0075B59, 0x0070254,
                        0x02A5F5F, 0x0075F5F, 0x00B0076, 0x0077700,
                        0x00B0039, 0x0063A2A, 0x01B3B2A, 0x0682828,
                        0x0680000, 0x0F05800, 0x00B003D, 0x04A0000,
                        0x0053200, 0x0502800, 0x0054E00, 0x0560000,
                        0x0530000, 0x00B0076, 0x0077700, 0x03E5F5F, // 20
                        0x0DC0058, 0x0050032, 0x0682828, 0x005002A,
                        0x0682C2C, 0x0682828, 0x0050039, 0x0682828,
                        0x0682C2C, 0x0CA0025, 0x0070013, 0x0070066,
                        0x0070014, 0x0070066, 0x0070014, 0x0F6005F,
                        0x00B3E00, 0x0065300, 0x00B4E00, 0x0065300,
                        0x0063B58, 0x0052A00, 0x0070058, 0x0184343,
                        0x0FC7576, 0x00A2828, 0x0052A00, 0x0065300,
                        0x00C0000, 0x0180000, 0x0682F2F, 0x0053C00,
                        0x0065300, 0x00C0000, 0x0182F2F, 0x0680000,
                        0x007042E, 0x0051600, 0x07A0000, 0x0070447, // 30
                        0x00B164B, 0x0770000, 0x00C3119, 0x0180000,
                        0x007005D, 0x0DC585F, 0x0830000, 0x0680000,
                        0x0695E5E, 0x0830000, 0x0680000, 0x00A0009,
                        0x00B0016, 0x00B0061, 0x0185A5A, 0x0075866,
                        0x0F00900, 0x0840004, 0x0052F26, 0x068002F,
                        0x0680027, 0x0056D00, 0x0180000, 0x0920000,
                        0x0F00959, 0x0180000, 0x00A0000, 0x0B50015,
                        0x0070011, 0x0070052, 0x0070066, 0x0070001,
                        0x0070001, 0x0070066, 0x0070001, 0x0070066,
                        0x0070001, 0x0070001, 0x0070066, 0x0070001, // 40
                        0x0070066, 0x0070002, 0x0070066, 0x0070001,
                        0x0075D5D, 0x0070052, 0x0075D5D, 0x0075D5D,
                        0x0590003, 0x00A5A00, 0x00B2A00, 0x01C7400,
                        0x00B3F00, 0x0185E00, 0x00B7458, 0x0B2005F,
                        0x0F00947, 0x0AE0000, 0x00B5E63, 0x0090000,
                        0x0186B2C, 0x00C006E, 0x0180000, 0x0180001,
                        0x0072828, 0x00B3000, 0x0680000, 0x00C3636,
                        0x0C10000, 0x0F07259, 0x0A90000, 0x0C45F00,
                        0x0073131, 0x0A95A5A, 0x0C45A5A, 0x0680000,
                        0x00A0000, 0x0690059, 0x0CA2C00, 0x0DC5931, // 50
                        0x0DC596B, 0x08D0000, 0x00A5A5A, 0x007000E,
                        0x0072E2E, 0x0074242, 0x0073334, 0x00B6265,
                        0x0DB5E5E, 0x0070064, 0x007075F, 0x0075F51,
                        0x00B1A03, 0x00F0051, 0x0D40068, 0x0075F5F,
                        0x0070052, 0x0070065, 0x0CF0038, 0x0180067,
                        0x00A4242, 0x005004E, 0x0070051, 0x0066000,
                        0x0065300, 0x005004F, 0x0065300, 0x0064650,
                        0x005004F, 0x0070050, 0x0070059, 0x0070052,
                        0x01B353E, 0x005002A, 0x0070058, 0x007000E,
                        0x0063B51, 0x005004E, 0x0075800, 0x0184343, // 60
                        0x00A4242, 0x0066000, 0x0063B00, 0x0070000,
                        0x0075000, 0x0605259, 0x0837125, 0x0680000,
                        0x0070023, 0x0070024, 0x0072F29, 0x0070041,
                        0x1060040, 0x0074900, 0x0075F5F, 0x0094A4A  // 64
                }
        }
};

/*
const uint8_t* IK1302_M_START = &ringM[42+42];
const uint8_t* IK1303_M_START = &ringM[42];
const uint8_t* IK1306_M_START = &ringM[0];
*/

const uint8_t* IK1302_M_START = &ringM[OFFSET_IK1302/*252+42+42*/];
const uint8_t* IK1303_M_START = &ringM[OFFSET_IK1303/*252+42+42+42*/];
const uint8_t* IK1306_M_START = &ringM[OFFSET_IK1306/*252+42+42+42+42*/];

IK1302 m_IK1302;
//uint16_t IK1302_uI_hi;         // Instruction HI word
IK1303 m_IK1303;

static const uint8_t IK1302_DCW[68] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x02, 0x00, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02,
  0x03, 0x00, 0x00, 0x00
};

static const uint8_t IK1302_DCWA[68] = {
  0x00, 0x02, 0x0C, 0x0C, 0x0C, 0x02, 0x02, 0x00, 0x02, 0x00, 0x10, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
  0x02, 0x02, 0x00, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0A, 0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0x02,
  0x02, 0x08, 0x08, 0x00, 0x0E, 0x00, 0x00, 0x08, 0x02, 0x04, 0x08, 0x02, 0x08, 0x02, 0x06, 0x0C,
  0x04, 0x04, 0x00, 0x0A, 0x0C, 0x02, 0x00, 0x02, 0x02, 0x02, 0x0C, 0x02, 0x02, 0x0C, 0x02, 0x02,
  0x00, 0x00, 0x02, 0x02
};

static const uint8_t IK1303_DCW[68] = {
  00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 03, 00, 00, 00, 00,
  00, 00, 00, 02, 00, 00, 00, 00, 03, 00, 00, 00, 01, 00, 00, 00,
  00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 03, 00, 01,
  00, 03, 00, 00, 02, 00, 00, 03, 02, 00, 00, 02, 03, 00, 00, 00,
  00, 00, 00, 00
};

static const uint8_t IK1306_DCW[68] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x02, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02,
  0x02, 0x02, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x02, 0x02, 0x00,
  0x02, 0x02, 0x00, 0x00
};

static const uint8_t IK1302_AND_AMK[1152] = {
  0x00, 0x00, 0x00, 0x10, 0x03, 0x1D, 0x00, 0x07, 0x1E, 0x10, 0x03, 0x1C, 0x0B, 0x07, 0x0C, 0x1E,
  0x00, 0x00, 0x15, 0x18, 0x09, 0x16, 0x18, 0x09, 0x16, 0x18, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0E, 0x1E, 0x33, 0x00, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00,
  0x00, 0x2F, 0x00, 0x2C, 0x00, 0x01, 0x11, 0x32, 0x00, 0x00, 0x00, 0x03, 0x00, 0x0E, 0x1A, 0x0F,
  0x0E, 0x0D, 0x19, 0x03, 0x2F, 0x0E, 0x0D, 0x08, 0x1C, 0x0C, 0x0D, 0x01, 0x00, 0x00, 0x03, 0x24,
  0x0F, 0x1C, 0x0C, 0x2F, 0x09, 0x1E, 0x34, 0x0E, 0x1E, 0x0C, 0x06, 0x0A, 0x0D, 0x00, 0x00, 0x00,
  0x00, 0x09, 0x0F, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x26, 0x06, 0x35, 0x34, 0x0D, 0x24,
  0x1E, 0x1A, 0x09, 0x0C, 0x0F, 0x3E, 0x00, 0x00, 0x1C, 0x03, 0x0E, 0x0A, 0x0F, 0x06, 0x3E, 0x00,
  0x0E, 0x42, 0x03, 0x01, 0x00, 0x00, 0x0E, 0x42, 0x33, 0x0D, 0x01, 0x08, 0x00, 0x01, 0x08, 0x04,
  0x06, 0x03, 0x0E, 0x2B, 0x3A, 0x09, 0x12, 0x1E, 0x33, 0x35, 0x03, 0x07, 0x0C, 0x1E, 0x1A, 0x00,
  0x00, 0x00, 0x35, 0x0C, 0x2F, 0x0E, 0x03, 0x01, 0x00, 0x00, 0x15, 0x24, 0x1E, 0x1A, 0x23, 0x1D,
  0x00, 0x00, 0x00, 0x00, 0x09, 0x0C, 0x2F, 0x09, 0x03, 0x00, 0x24, 0x0C, 0x0F, 0x3E, 0x09, 0x1E,
  0x42, 0x03, 0x07, 0x0B, 0x22, 0x03, 0x07, 0x0B, 0x0D, 0x0C, 0x03, 0x0E, 0x1E, 0x3A, 0x2B, 0x3C,
  0x03, 0x00, 0x09, 0x34, 0x0E, 0x1E, 0x0C, 0x1E, 0x2E, 0x01, 0x31, 0x2E, 0x01, 0x31, 0x00, 0x00,
  0x00, 0x2E, 0x30, 0x03, 0x2E, 0x30, 0x03, 0x00, 0x00, 0x00, 0x2E, 0x2D, 0x00, 0x2E, 0x2D, 0x00,
  0x00, 0x00, 0x00, 0x3B, 0x04, 0x2F, 0x37, 0x12, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x08,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x13, 0x00, 0x01, 0x13, 0x00, 0x01, 0x13, 0x04, 0x2E, 0x00,
  0x00, 0x2E, 0x00, 0x00, 0x2E, 0x00, 0x00, 0x3E, 0x07, 0x10, 0x42, 0x03, 0x00, 0x2C, 0x07, 0x1E,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x0F, 0x10, 0x03, 0x00, 0x1C, 0x03,
  0x0F, 0x1D, 0x03, 0x32, 0x00, 0x2B, 0x14, 0x00, 0x00, 0x08, 0x00, 0x04, 0x14, 0x00, 0x00, 0x32,
  0x00, 0x00, 0x32, 0x0C, 0x0A, 0x32, 0x00, 0x00, 0x32, 0x00, 0x00, 0x32, 0x00, 0x21, 0x15, 0x18,
  0x21, 0x16, 0x18, 0x00, 0x17, 0x18, 0x19, 0x1A, 0x18, 0x19, 0x16, 0x18, 0x09, 0x16, 0x18, 0x2B,
  0x15, 0x00, 0x00, 0x17, 0x00, 0x00, 0x17, 0x00, 0x12, 0x1B, 0x0E, 0x0F, 0x1B, 0x0E, 0x23, 0x2B,
  0x0A, 0x2C, 0x18, 0x00, 0x2A, 0x18, 0x07, 0x0B, 0x03, 0x04, 0x32, 0x14, 0x00, 0x32, 0x32, 0x11,
  0x00, 0x08, 0x00, 0x09, 0x0C, 0x15, 0x03, 0x00, 0x00, 0x06, 0x3C, 0x00, 0x00, 0x2C, 0x00, 0x00,
  0x2A, 0x00, 0x09, 0x16, 0x00, 0x00, 0x00, 0x11, 0x00, 0x09, 0x16, 0x18, 0x09, 0x1E, 0x00, 0x00,
  0x07, 0x0A, 0x29, 0x40, 0x33, 0x29, 0x00, 0x0F, 0x0B, 0x0F, 0x10, 0x03, 0x08, 0x24, 0x03, 0x23,
  0x32, 0x01, 0x1D, 0x32, 0x08, 0x00, 0x32, 0x08, 0x32, 0x32, 0x08, 0x23, 0x32, 0x08, 0x0F, 0x23,
  0x23, 0x04, 0x09, 0x1E, 0x0F, 0x00, 0x00, 0x14, 0x00, 0x00, 0x08, 0x37, 0x00, 0x00, 0x37, 0x00,
  0x00, 0x37, 0x00, 0x00, 0x01, 0x31, 0x00, 0x01, 0x31, 0x00, 0x01, 0x31, 0x36, 0x1A, 0x30, 0x0D,
  0x00, 0x30, 0x0D, 0x00, 0x30, 0x0D, 0x30, 0x03, 0x00, 0x30, 0x03, 0x00, 0x30, 0x03, 0x2B, 0x2D,
  0x00, 0x00, 0x2D, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x0A, 0x30, 0x03, 0x00, 0x30, 0x03, 0x00, 0x30,
  0x03, 0x00, 0x01, 0x31, 0x00, 0x01, 0x31, 0x00, 0x01, 0x31, 0x00, 0x2D, 0x00, 0x00, 0x2D, 0x00,
  0x00, 0x2D, 0x00, 0x2C, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x09, 0x18, 0x00, 0x07, 0x1E, 0x0F, 0x01,
  0x00, 0x08, 0x1C, 0x0A, 0x08, 0x14, 0x00, 0x00, 0x32, 0x00, 0x00, 0x32, 0x2B, 0x00, 0x32, 0x00,
  0x00, 0x32, 0x27, 0x36, 0x08, 0x09, 0x0C, 0x1E, 0x02, 0x1D, 0x0F, 0x0C, 0x0F, 0x26, 0x07, 0x22,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1D, 0x23, 0x23, 0x09, 0x23, 0x0C, 0x03,
  0x23, 0x23, 0x02, 0x35, 0x03, 0x0F, 0x00, 0x00, 0x00, 0x04, 0x0C, 0x01, 0x12, 0x00, 0x08, 0x00,
  0x32, 0x0A, 0x00, 0x00, 0x06, 0x18, 0x00, 0x17, 0x18, 0x00, 0x17, 0x18, 0x00, 0x00, 0x01, 0x13,
  0x00, 0x01, 0x13, 0x04, 0x01, 0x13, 0x00, 0x00, 0x00, 0x09, 0x15, 0x18, 0x00, 0x35, 0x03, 0x0E,
  0x03, 0x09, 0x0C, 0x1B, 0x1E, 0x0F, 0x1B, 0x08, 0x00, 0x00, 0x1C, 0x03, 0x1E, 0x15, 0x02, 0x0C,
  0x00, 0x07, 0x1E, 0x10, 0x0F, 0x09, 0x32, 0x1E, 0x0F, 0x08, 0x09, 0x1E, 0x1A, 0x18, 0x1D, 0x17,
  0x03, 0x0F, 0x3E, 0x07, 0x0B, 0x1A, 0x1D, 0x28, 0x00, 0x0E, 0x28, 0x08, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x06, 0x03, 0x00, 0x09, 0x00, 0x04, 0x2B, 0x23, 0x04, 0x08, 0x08, 0x00, 0x08, 0x0E, 0x03,
  0x00, 0x2B, 0x2F, 0x0D, 0x12, 0x03, 0x04, 0x01, 0x08, 0x00, 0x01, 0x08, 0x00, 0x01, 0x08, 0x04,
  0x0F, 0x1D, 0x2F, 0x0E, 0x03, 0x23, 0x07, 0x1E, 0x0D, 0x0F, 0x12, 0x00, 0x23, 0x24, 0x1E, 0x23,
  0x0F, 0x04, 0x26, 0x12, 0x15, 0x03, 0x12, 0x04, 0x24, 0x2F, 0x0F, 0x12, 0x04, 0x01, 0x0F, 0x07,
  0x1E, 0x0F, 0x00, 0x01, 0x0E, 0x0F, 0x20, 0x05, 0x00, 0x07, 0x12, 0x0E, 0x08, 0x1E, 0x00, 0x10,
  0x03, 0x0F, 0x04, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
  0x00, 0x01, 0x00, 0x00, 0x05, 0x00, 0x17, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x1A, 0x18, 0x00, 0x17,
  0x03, 0x32, 0x09, 0x0F, 0x32, 0x07, 0x0C, 0x0C, 0x1A, 0x0F, 0x14, 0x00, 0x00, 0x32, 0x00, 0x00,
  0x32, 0x00, 0x00, 0x0E, 0x1E, 0x15, 0x00, 0x00, 0x02, 0x00, 0x00, 0x02, 0x00, 0x0E, 0x08, 0x0E,
  0x1D, 0x23, 0x1E, 0x3A, 0x3A, 0x1D, 0x04, 0x15, 0x00, 0x00, 0x3A, 0x00, 0x00, 0x3A, 0x00, 0x00,
  0x3A, 0x00, 0x0D, 0x0E, 0x03, 0x0F, 0x00, 0x3B, 0x3C, 0x2F, 0x37, 0x3C, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x02, 0x24, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x07, 0x0B, 0x22,
  0x03, 0x04, 0x00, 0x00, 0x39, 0x04, 0x25, 0x08, 0x03, 0x07, 0x0F, 0x12, 0x2C, 0x00, 0x2B, 0x2A,
  0x26, 0x0D, 0x07, 0x0F, 0x04, 0x0B, 0x08, 0x01, 0x10, 0x0D, 0x09, 0x00, 0x00, 0x00, 0x01, 0x08,
  0x04, 0x01, 0x08, 0x23, 0x01, 0x08, 0x00, 0x00, 0x1B, 0x00, 0x00, 0x1B, 0x1F, 0x0E, 0x1B, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x2C, 0x00, 0x1B, 0x00, 0x00, 0x00, 0x01, 0x0F, 0x0D, 0x01, 0x09, 0x1E,
  0x2B, 0x00, 0x23, 0x1A, 0x07, 0x1E, 0x0C, 0x0F, 0x00, 0x00, 0x1E, 0x12, 0x00, 0x00, 0x12, 0x00,
  0x00, 0x12, 0x1A, 0x1E, 0x00, 0x10, 0x0F, 0x24, 0x1E, 0x34, 0x1D, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x09, 0x2F, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x09, 0x15, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x28, 0x00, 0x00, 0x2B, 0x00, 0x00, 0x00, 0x09, 0x0C, 0x23,
  0x24, 0x0C, 0x1E, 0x0F, 0x00, 0x07, 0x03, 0x0F, 0x00, 0x00, 0x00, 0x01, 0x0F, 0x07, 0x0B, 0x0F,
  0x25, 0x0F, 0x0F, 0x04, 0x00, 0x00, 0x00, 0x12, 0x09, 0x0C, 0x12, 0x00, 0x00, 0x00, 0x12, 0x00,
  0x00, 0x00, 0x09, 0x0C, 0x03, 0x00, 0x00, 0x00, 0x04, 0x32, 0x24, 0x0F, 0x23, 0x0E, 0x0D, 0x00,
  0x00, 0x00, 0x00, 0x09, 0x1E, 0x1A, 0x07, 0x0B, 0x0F, 0x07, 0x0C, 0x1E, 0x1A, 0x0F, 0x00, 0x0E,
  0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x08, 0x12, 0x00, 0x01, 0x0B, 0x00, 0x00, 0x00, 0x00,
  0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x0B, 0x00, 0x00, 0x12, 0x00, 0x00, 0x12,
  0x04, 0x0C, 0x12, 0x32, 0x00, 0x00, 0x32, 0x00, 0x00, 0x08, 0x36, 0x00, 0x02, 0x0D, 0x00, 0x01,
  0x0F, 0x0D, 0x00, 0x0E, 0x1E, 0x1E, 0x00, 0x10, 0x0F, 0x07, 0x0B, 0x34, 0x0F, 0x1D, 0x1D, 0x04,
  0x08, 0x36, 0x00, 0x08, 0x12, 0x00, 0x00, 0x03, 0x1E, 0x0F, 0x26, 0x0A, 0x02, 0x26, 0x40, 0x08
};

static const uint8_t IK1303_AND_AMK[1152] = {
  0x2C, 0x23, 0x00, 0x2C, 0x23, 0x00, 0x2C, 0x23, 0x30, 0x31, 0x32, 0x00, 0x31, 0x32, 0x12, 0x31,
  0x32, 0x30, 0x00, 0x00, 0x00, 0x11, 0x23, 0x00, 0x1F, 0x06, 0x00, 0x31, 0x00, 0x1C, 0x31, 0x00,
  0x00, 0x31, 0x08, 0x1D, 0x2C, 0x02, 0x0E, 0x2C, 0x02, 0x01, 0x2C, 0x02, 0x08, 0x08, 0x3A, 0x00,
  0x00, 0x3A, 0x01, 0x05, 0x3A, 0x11, 0x18, 0x0A, 0x2B, 0x00, 0x01, 0x33, 0x02, 0x24, 0x25, 0x37,
  0x3A, 0x18, 0x31, 0x3A, 0x1F, 0x31, 0x3A, 0x3E, 0x37, 0x02, 0x06, 0x31, 0x02, 0x12, 0x31, 0x10,
  0x19, 0x39, 0x02, 0x26, 0x33, 0x09, 0x08, 0x19, 0x19, 0x08, 0x01, 0x14, 0x0C, 0x00, 0x00, 0x00,
  0x1B, 0x06, 0x01, 0x26, 0x00, 0x21, 0x12, 0x14, 0x24, 0x06, 0x12, 0x00, 0x39, 0x00, 0x21, 0x08,
  0x22, 0x00, 0x10, 0x14, 0x00, 0x20, 0x00, 0x00, 0x39, 0x02, 0x00, 0x06, 0x25, 0x25, 0x19, 0x02,
  0x16, 0x09, 0x11, 0x19, 0x16, 0x11, 0x13, 0x18, 0x08, 0x10, 0x18, 0x00, 0x01, 0x1F, 0x06, 0x12,
  0x1A, 0x12, 0x2E, 0x19, 0x02, 0x00, 0x33, 0x38, 0x00, 0x0D, 0x06, 0x3B, 0x13, 0x0A, 0x02, 0x00,
  0x27, 0x00, 0x00, 0x00, 0x33, 0x13, 0x3C, 0x00, 0x11, 0x14, 0x04, 0x11, 0x1D, 0x34, 0x13, 0x01,
  0x00, 0x14, 0x27, 0x00, 0x2C, 0x10, 0x21, 0x2C, 0x02, 0x33, 0x00, 0x00, 0x00, 0x37, 0x12, 0x2A,
  0x31, 0x02, 0x00, 0x12, 0x06, 0x09, 0x37, 0x12, 0x2A, 0x31, 0x14, 0x0C, 0x00, 0x00, 0x00, 0x39,
  0x0D, 0x12, 0x10, 0x0F, 0x00, 0x00, 0x27, 0x03, 0x37, 0x12, 0x0C, 0x31, 0x05, 0x00, 0x31, 0x00,
  0x00, 0x37, 0x20, 0x0A, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x13, 0x0E, 0x01, 0x0D, 0x11,
  0x05, 0x25, 0x24, 0x0A, 0x24, 0x0C, 0x08, 0x0D, 0x21, 0x00, 0x00, 0x00, 0x37, 0x06, 0x3A, 0x31,
  0x05, 0x02, 0x0A, 0x1D, 0x16, 0x38, 0x14, 0x0C, 0x00, 0x08, 0x06, 0x20, 0x1B, 0x34, 0x0E, 0x02,
  0x06, 0x00, 0x02, 0x1F, 0x19, 0x20, 0x08, 0x37, 0x10, 0x21, 0x31, 0x12, 0x0C, 0x00, 0x00, 0x00,
  0x01, 0x2D, 0x30, 0x01, 0x2D, 0x00, 0x01, 0x2D, 0x30, 0x33, 0x34, 0x06, 0x01, 0x18, 0x00, 0x01,
  0x18, 0x08, 0x31, 0x20, 0x34, 0x31, 0x20, 0x05, 0x31, 0x20, 0x08, 0x1F, 0x3A, 0x20, 0x14, 0x3A,
  0x20, 0x0C, 0x00, 0x20, 0x0A, 0x20, 0x06, 0x30, 0x1F, 0x0C, 0x00, 0x20, 0x00, 0x35, 0x20, 0x05,
  0x34, 0x14, 0x09, 0x30, 0x20, 0x11, 0x08, 0x18, 0x18, 0x08, 0x18, 0x18, 0x08, 0x33, 0x20, 0x04,
  0x16, 0x06, 0x36, 0x06, 0x0C, 0x01, 0x03, 0x00, 0x2F, 0x08, 0x18, 0x1C, 0x00, 0x18, 0x00, 0x20,
  0x18, 0x00, 0x18, 0x14, 0x35, 0x1D, 0x06, 0x14, 0x00, 0x3B, 0x06, 0x20, 0x05, 0x34, 0x14, 0x09,
  0x19, 0x00, 0x21, 0x05, 0x3A, 0x3A, 0x06, 0x3A, 0x3A, 0x05, 0x3A, 0x3A, 0x01, 0x23, 0x00, 0x01,
  0x23, 0x00, 0x01, 0x23, 0x08, 0x01, 0x32, 0x02, 0x01, 0x32, 0x02, 0x01, 0x32, 0x02, 0x15, 0x04,
  0x03, 0x15, 0x17, 0x03, 0x15, 0x17, 0x03, 0x07, 0x2B, 0x03, 0x07, 0x17, 0x03, 0x07, 0x17, 0x03,
  0x04, 0x1E, 0x06, 0x1E, 0x42, 0x0E, 0x09, 0x11, 0x13, 0x0F, 0x29, 0x05, 0x09, 0x28, 0x09, 0x09,
  0x09, 0x01, 0x08, 0x0B, 0x0B, 0x1B, 0x0B, 0x0B, 0x1E, 0x0B, 0x00, 0x08, 0x0B, 0x0B, 0x0E, 0x0B,
  0x0B, 0x1A, 0x0B, 0x00, 0x11, 0x1D, 0x06, 0x08, 0x10, 0x04, 0x02, 0x06, 0x2F, 0x1F, 0x1C, 0x2F,
  0x00, 0x1C, 0x1C, 0x09, 0x18, 0x11, 0x0B, 0x0C, 0x0C, 0x0B, 0x02, 0x30, 0x00, 0x00, 0x00, 0x25,
  0x1C, 0x04, 0x01, 0x1C, 0x1D, 0x1D, 0x06, 0x08, 0x01, 0x30, 0x21, 0x42, 0x2E, 0x11, 0x19, 0x25,
  0x01, 0x16, 0x00, 0x00, 0x03, 0x0C, 0x0A, 0x19, 0x0A, 0x19, 0x0E, 0x16, 0x1B, 0x11, 0x1D, 0x10,
  0x3C, 0x3A, 0x05, 0x20, 0x08, 0x10, 0x06, 0x22, 0x19, 0x02, 0x22, 0x18, 0x06, 0x0C, 0x01, 0x10,
  0x00, 0x00, 0x00, 0x11, 0x13, 0x0A, 0x2B, 0x03, 0x0A, 0x17, 0x03, 0x0A, 0x17, 0x03, 0x12, 0x14,
  0x06, 0x12, 0x02, 0x00, 0x0A, 0x02, 0x00, 0x0A, 0x24, 0x0C, 0x00, 0x0A, 0x21, 0x06, 0x20, 0x18,
  0x0A, 0x21, 0x21, 0x35, 0x02, 0x08, 0x10, 0x02, 0x05, 0x00, 0x12, 0x0F, 0x11, 0x24, 0x21, 0x35,
  0x02, 0x05, 0x06, 0x25, 0x0C, 0x06, 0x02, 0x12, 0x14, 0x02, 0x18, 0x12, 0x20, 0x14, 0x00, 0x00,
  0x21, 0x18, 0x12, 0x0B, 0x0A, 0x24, 0x06, 0x00, 0x20, 0x08, 0x25, 0x02, 0x00, 0x24, 0x02, 0x35,
  0x18, 0x12, 0x14, 0x34, 0x00, 0x18, 0x12, 0x14, 0x0C, 0x00, 0x0A, 0x21, 0x35, 0x02, 0x00, 0x00,
  0x26, 0x03, 0x06, 0x27, 0x03, 0x06, 0x27, 0x03, 0x26, 0x03, 0x00, 0x27, 0x03, 0x00, 0x27, 0x03,
  0x00, 0x11, 0x04, 0x03, 0x00, 0x36, 0x03, 0x00, 0x36, 0x03, 0x06, 0x04, 0x03, 0x07, 0x17, 0x03,
  0x07, 0x17, 0x03, 0x0A, 0x20, 0x24, 0x25, 0x03, 0x06, 0x08, 0x02, 0x0B, 0x12, 0x04, 0x16, 0x0A,
  0x17, 0x03, 0x0A, 0x17, 0x03, 0x07, 0x2B, 0x00, 0x07, 0x17, 0x00, 0x07, 0x17, 0x25, 0x00, 0x07,
  0x2B, 0x03, 0x07, 0x17, 0x03, 0x07, 0x17, 0x03, 0x36, 0x03, 0x11, 0x24, 0x1D, 0x24, 0x03, 0x06,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x04, 0x03, 0x15, 0x17, 0x03,
  0x15, 0x17, 0x03, 0x12, 0x1D, 0x1D, 0x14, 0x06, 0x12, 0x06, 0x00, 0x1C, 0x1C, 0x00, 0x1C, 0x2F,
  0x00, 0x06, 0x20, 0x20, 0x00, 0x0B, 0x02, 0x00, 0x0B, 0x02, 0x00, 0x36, 0x00, 0x01, 0x18, 0x18,
  0x01, 0x18, 0x18, 0x01, 0x18, 0x18, 0x00, 0x00, 0x00, 0x33, 0x00, 0x08, 0x18, 0x04, 0x28, 0x1F,
  0x0C, 0x08, 0x25, 0x06, 0x0E, 0x06, 0x00, 0x18, 0x06, 0x0E, 0x00, 0x16, 0x16, 0x00, 0x1D, 0x20,
  0x20, 0x18, 0x07, 0x06, 0x35, 0x10, 0x34, 0x05, 0x09, 0x24, 0x05, 0x09, 0x09, 0x09, 0x09, 0x01,
  0x0D, 0x10, 0x09, 0x08, 0x25, 0x33, 0x2E, 0x06, 0x1B, 0x06, 0x00, 0x13, 0x1C, 0x00, 0x00, 0x1C,
  0x00, 0x00, 0x1C, 0x00, 0x38, 0x1D, 0x3E, 0x05, 0x1D, 0x3E, 0x05, 0x1D, 0x3E, 0x05, 0x1D, 0x20,
  0x1D, 0x00, 0x18, 0x00, 0x33, 0x34, 0x06, 0x39, 0x3C, 0x21, 0x01, 0x3C, 0x01, 0x06, 0x1F, 0x19,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0A, 0x17, 0x03, 0x11, 0x13, 0x14, 0x00,
  0x05, 0x35, 0x00, 0x05, 0x34, 0x00, 0x00, 0x34, 0x00, 0x00, 0x34, 0x38, 0x04, 0x02, 0x33, 0x00,
  0x11, 0x04, 0x00, 0x00, 0x0C, 0x00, 0x26, 0x33, 0x09, 0x09, 0x20, 0x08, 0x18, 0x0F, 0x36, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x27, 0x05, 0x30, 0x09, 0x20, 0x20, 0x06, 0x20, 0x21, 0x00, 0x00, 0x0A,
  0x3A, 0x10, 0x2B, 0x18, 0x38, 0x38, 0x0E, 0x02, 0x16, 0x0C, 0x35, 0x05, 0x00, 0x00, 0x19, 0x30,
  0x00, 0x08, 0x1C, 0x18, 0x00, 0x1C, 0x00, 0x00, 0x05, 0x3A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x38, 0x20, 0x1F, 0x0C, 0x08, 0x25, 0x06, 0x08, 0x00, 0x00, 0x34, 0x06, 0x1C, 0x05, 0x25,
  0x1C, 0x25, 0x1F, 0x18, 0x34, 0x33, 0x20, 0x26, 0x0B, 0x02, 0x00, 0x34, 0x09, 0x09, 0x00, 0x06,
  0x36, 0x00, 0x00, 0x11, 0x24, 0x0B, 0x34, 0x20, 0x20, 0x00, 0x00, 0x39, 0x02, 0x08, 0x1D, 0x00,
  0x00, 0x08, 0x00, 0x40, 0x00, 0x00, 0x37, 0x08, 0x1D, 0x00, 0x00, 0x20, 0x00, 0x35, 0x20, 0x05,
  0x34, 0x34, 0x12, 0x14, 0x24, 0x34, 0x2E, 0x30, 0x1F, 0x06, 0x08, 0x01, 0x05, 0x30, 0x04, 0x30,
  0x2E, 0x06, 0x0E, 0x00, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x34, 0x00, 0x0A, 0x06, 0x1B,
  0x1F, 0x00, 0x00, 0x25, 0x00, 0x3B, 0x25, 0x10, 0x06, 0x00, 0x00, 0x0A, 0x10, 0x07, 0x03, 0x0A,
  0x10, 0x01, 0x00, 0x00, 0x00, 0x16, 0x19, 0x35, 0x06, 0x12, 0x10, 0x19, 0x10, 0x00, 0x00, 0x00,
  0x3A, 0x11, 0x06, 0x09, 0x35, 0x16, 0x10, 0x40, 0x13, 0x0D, 0x24, 0x3E, 0x10, 0x0E, 0x12, 0x33,
  0x03, 0x06, 0x30, 0x00, 0x26, 0x00, 0x00, 0x27, 0x00, 0x00, 0x3B, 0x08, 0x06, 0x0C, 0x0C, 0x20,
  0x0A, 0x06, 0x11, 0x14, 0x00, 0x18, 0x24, 0x06, 0x0A, 0x10, 0x18, 0x11, 0x24, 0x18, 0x10, 0x25,
  0x05, 0x06, 0x3C, 0x05, 0x06, 0x00, 0x00, 0x06, 0x0C, 0x0C, 0x00, 0x00, 0x12, 0x24, 0x1D, 0x1D
};

static const uint8_t IK1306_AND_AMK[1152] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2C, 0x2A, 0x27, 0x13, 0x2B, 0x27, 0x13,
  0x2B, 0x27, 0x34, 0x2A, 0x27, 0x13, 0x2B, 0x27, 0x13, 0x2B, 0x27, 0x29, 0x2A, 0x35, 0x29, 0x2B,
  0x35, 0x29, 0x2B, 0x35, 0x29, 0x12, 0x35, 0x29, 0x42, 0x35, 0x29, 0x42, 0x35, 0x2E, 0x00, 0x00,
  0x2D, 0x02, 0x00, 0x00, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x2D, 0x02, 0x00, 0x00, 0x00, 0x00, 0x03,
  0x12, 0x05, 0x2D, 0x02, 0x00, 0x00, 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
  0x42, 0x0E, 0x02, 0x00, 0x24, 0x02, 0x00, 0x24, 0x02, 0x00, 0x30, 0x1D, 0x05, 0x2F, 0x1D, 0x00,
  0x00, 0x1D, 0x00, 0x22, 0x00, 0x00, 0x2D, 0x02, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x2D,
  0x02, 0x00, 0x00, 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x24, 0x25, 0x00, 0x31, 0x00, 0x00, 0x2D, 0x02, 0x00, 0x00, 0x00, 0x00,
  0x0E, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x0E, 0x34, 0x05, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
  0x18, 0x00, 0x00, 0x00, 0x18, 0x25, 0x00, 0x03, 0x18, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x03, 0x39,
  0x00, 0x00, 0x00, 0x14, 0x18, 0x00, 0x36, 0x00, 0x00, 0x03, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x03, 0x18, 0x00, 0x00, 0x00, 0x00, 0x37, 0x1E, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00,
  0x00, 0x01, 0x06, 0x07, 0x01, 0x06, 0x07, 0x01, 0x06, 0x07, 0x34, 0x12, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x2D, 0x02, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x2D,
  0x02, 0x00, 0x00, 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
  0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
  0x01, 0x25, 0x00, 0x01, 0x25, 0x00, 0x24, 0x02, 0x00, 0x03, 0x04, 0x02, 0x03, 0x04, 0x02, 0x24,
  0x02, 0x00, 0x01, 0x06, 0x07, 0x01, 0x06, 0x07, 0x24, 0x02, 0x00, 0x01, 0x04, 0x08, 0x01, 0x04,
  0x08, 0x24, 0x00, 0x1A, 0x03, 0x06, 0x09, 0x03, 0x06, 0x09, 0x24, 0x00, 0x02, 0x03, 0x25, 0x00,
  0x03, 0x25, 0x00, 0x24, 0x25, 0x00, 0x03, 0x00, 0x38, 0x03, 0x00, 0x0B, 0x03, 0x25, 0x00, 0x24,
  0x25, 0x00, 0x24, 0x25, 0x0E, 0x05, 0x00, 0x00, 0x03, 0x25, 0x00, 0x03, 0x25, 0x00, 0x03, 0x25,
  0x00, 0x00, 0x00, 0x19, 0x05, 0x00, 0x19, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x29, 0x12, 0x00, 0x21, 0x00, 0x00, 0x21, 0x24, 0x25, 0x03, 0x25, 0x00, 0x0D, 0x02, 0x00,
  0x0D, 0x02, 0x00, 0x0D, 0x02, 0x00, 0x17, 0x00, 0x00, 0x17, 0x24, 0x05, 0x00, 0x00, 0x24, 0x00,
  0x05, 0x24, 0x00, 0x05, 0x24, 0x00, 0x05, 0x24, 0x25, 0x00, 0x24, 0x25, 0x00, 0x24, 0x25, 0x00,
  0x13, 0x0A, 0x00, 0x00, 0x03, 0x0B, 0x00, 0x28, 0x00, 0x00, 0x03, 0x05, 0x00, 0x03, 0x05, 0x00,
  0x03, 0x05, 0x1B, 0x03, 0x00, 0x0B, 0x03, 0x0B, 0x00, 0x00, 0x00, 0x2C, 0x02, 0x00, 0x24, 0x02,
  0x00, 0x24, 0x02, 0x00, 0x0E, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x0E, 0x0F, 0x0F,
  0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x16, 0x00, 0x00, 0x16, 0x00, 0x00, 0x16, 0x00, 0x00,
  0x17, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x17, 0x00, 0x00, 0x17, 0x24, 0x02,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x12, 0x00, 0x14, 0x0F, 0x0F, 0x00, 0x00, 0x00,
  0x0F, 0x00, 0x00, 0x24, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x13, 0x0A, 0x00, 0x00,
  0x03, 0x0B, 0x00, 0x00, 0x00, 0x1B, 0x18, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x0F,
  0x0F, 0x00, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x1B, 0x03, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x3B, 0x00, 0x00, 0x3B, 0x00, 0x12, 0x14, 0x00, 0x0E, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x05,
  0x24, 0x02, 0x03, 0x00, 0x25, 0x03, 0x00, 0x25, 0x03, 0x00, 0x25, 0x00, 0x00, 0x20, 0x00, 0x00,
  0x20, 0x00, 0x00, 0x20, 0x00, 0x11, 0x05, 0x00, 0x11, 0x05, 0x00, 0x11, 0x05, 0x00, 0x11, 0x25,
  0x00, 0x11, 0x25, 0x00, 0x11, 0x25, 0x0E, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x03,
  0x00, 0x00, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0F, 0x0F, 0x2A, 0x0F, 0x0F, 0x12, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x1B, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x03, 0x15, 0x00, 0x03, 0x15, 0x00,
  0x03, 0x15, 0x00, 0x1B, 0x02, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x02, 0x00, 0x00, 0x00, 0x00, 0x03,
  0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x12, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x24, 0x23, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x23, 0x02, 0x00,
  0x26, 0x27, 0x00, 0x28, 0x27, 0x00, 0x28, 0x27, 0x00, 0x00, 0x26, 0x27, 0x00, 0x28, 0x27, 0x00,
  0x28, 0x27, 0x29, 0x2A, 0x27, 0x29, 0x2B, 0x27, 0x29, 0x2B, 0x3A, 0x0E, 0x12, 0x12, 0x12, 0x00,
  0x00, 0x10, 0x00, 0x00, 0x0E, 0x12, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x0E, 0x0F, 0x0F,
  0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x25, 0x00, 0x0E, 0x0F, 0x0F, 0x0F, 0x0E,
  0x0F, 0x0F, 0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x18,
  0x00, 0x24, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1D, 0x00, 0x00, 0x1D, 0x00,
  0x00, 0x1D, 0x00, 0x1F, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x18, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x05, 0x00, 0x16, 0x05, 0x00, 0x16, 0x05, 0x00, 0x16,
  0x02, 0x00, 0x16, 0x02, 0x00, 0x16, 0x02, 0x03, 0x21, 0x02, 0x03, 0x21, 0x02, 0x03, 0x21, 0x02,
  0x18, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x03, 0x0B, 0x00,
  0x00, 0x00, 0x03, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x03,
  0x3E, 0x00, 0x00, 0x00, 0x24, 0x18, 0x03, 0x18, 0x05, 0x03, 0x18, 0x05, 0x00, 0x03, 0x00, 0x32,
  0x03, 0x00, 0x32, 0x03, 0x00, 0x32, 0x24, 0x33, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x21, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x2C, 0x2A, 0x27, 0x13, 0x2B, 0x27, 0x00,
  0x00, 0x03, 0x25, 0x00, 0x03, 0x25, 0x00, 0x13, 0x09, 0x00, 0x00, 0x3B, 0x05, 0x00, 0x3B, 0x05,
  0x00, 0x3B, 0x05, 0x00, 0x0D, 0x05, 0x00, 0x0D, 0x05, 0x00, 0x0D, 0x05, 0x13, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x07, 0x1B, 0x18, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17,
  0x00, 0x00, 0x17, 0x0E, 0x05, 0x0D, 0x02, 0x18, 0x00, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x09, 0x00, 0x00, 0x09, 0x00, 0x00,
  0x09, 0x00, 0x0E, 0x0F, 0x02, 0x24, 0x25, 0x00, 0x24, 0x25, 0x00, 0x00, 0x00, 0x00, 0x29, 0x0F,
  0x0F, 0x0F, 0x12, 0x00, 0x00, 0x29, 0x12, 0x00, 0x29, 0x42, 0x00, 0x13, 0x0F, 0x00, 0x3E, 0x00,
  0x00, 0x3E, 0x00, 0x00, 0x3E, 0x00, 0x1B, 0x03, 0x00, 0x0B, 0x03, 0x0B, 0x13, 0x39, 0x24, 0x0E,
  0x02, 0x00, 0x24, 0x02, 0x00, 0x13, 0x07, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
  0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
  0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
  0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
  0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42
};

IK1306 m_IK1306;

//TODO: remove me static
inline void __attribute__((always_inline)) _CycleE(int J_signal_I, mtick_t &signal_I) {
	IK1302_Tick(signal_I, J_signal_I);
	IK1303_Tick(signal_I, J_signal_I);
	IK1306_Tick(signal_I, J_signal_I);
}


//TODO: remove me
inline void __attribute__((always_inline)) _CycleB(int J_signal_I, mtick_t &signal_I) {
	_CycleE(J_signal_I, signal_I);
	signal_I++;
}

#define CycleE(J_signal_I)	_CycleE(J_signal_I, signal_I)
#define CycleB(J_signal_I)	_CycleB(J_signal_I, signal_I)

#ifdef out_dump

uint16_t step = 0;

void dumpm(uint16_t sig, uint16_t cyc) {
 uint16_t i;
        printf("st %2.2d cy %3.3d si %2.2d\n(%d,%d)1302 R dump:\n",step,cyc,sig,IK1302_key_x,IK1302_key_y);
        for(i=0;i<42;i++){
                if((i % 15) == 0) printf("\n%2.2X ", i);
                printf("%2.2X ", IK1302_R[i]);
        }/*
        printf("\n\nIK1302 M dump: \n\n");
        for(i=0;i<42;i++){
                if((i % 15) == 0) printf("\n\n %4.4X ", i);
                printf("%2.2X ", m_IK1302.M[i]);
        }*/
        printf("\n1303 R dump:\n");
        for(i=0;i<42;i++){
                if((i % 15) == 0) printf("\n%2.2X ", i);
                printf("%2.2X ", m_IK1303.R[i]);
        }/*
        printf("\n\nIK1303 M dump: \n\n");
        for(i=0;i<42;i++){
                if((i % 15) == 0) printf("\n\n %4.4X ", i);
                printf("%2.2X ", m_IK1303.M[i]);
        }*/
        printf("\n1306 R dump:\n");
        for(i=0;i<42;i++){
                if((i % 15) == 0) printf("\n%2.2X ", i);
                printf("%2.2X ", IK1306_R[i]);
        }/*
        printf("\n\nIK1306 M dump: \n\n");
        for(i=0;i<42;i++){
                if((i % 15) == 0) printf("\n\n %4.4X ", i);
                printf("%2.2X ", m_IK1306.M[i]);
        }

                        printf("\n\nIR2.1 M dump: \n\n");
                        for(i=0;i<252;i++){
                                if((i % 15) == 0) printf("\n\n %4.4X ", i);
                                printf("%2.2X ", IR2_1.M[i]);
                        }
                        printf("\n\nIR2.2 M dump: \n\n");
                        for(i=0;i<252;i++){
                                if((i % 15) == 0) printf("\n\n %4.4X ", i);
                                printf("%2.2X ", IR2_2.M[i]);
                        }*/
        puts("\n");
}
#endif

inline usize IK1302_GoZero(void) {
    uint32_t uI = ROM.IK1302.instructions[(uint16_t)m_IK1302.R[36] + 16 * (uint16_t)m_IK1302.R[39]];
    const usize IK1302_uI_hi = uI >> 16;


    m_IK1302.pAND_AMK = (uint8_t*) &IK1302_AND_AMK[MUL9((uint8_t) uI)];
    m_IK1302.pAND_AMK1 = (uint8_t*) &IK1302_AND_AMK[MUL9((((uint16_t) uI) >> 8))];

    m_IK1302.MOD = (uint8_t) (uI >> 24);
    m_IK1302.flag_FC = IK1302_uI_hi & 0x00FC;
    if (m_IK1302.flag_FC== 0) m_IK1302.T = 0;

    m_IK1302.key_xm = m_IK1302.key_x - 1;
  
  return IK1302_uI_hi;
}

inline usize IK1303_GoZero(void) {
    uint32_t uI = ROM.IK1303.instructions[(uint16_t)m_IK1303.R[36] + 16 * (uint16_t)m_IK1303.R[39]];
    const usize IK1303_uI_hi = uI >> 16;

    m_IK1303.pAND_AMK = (uint8_t*) &IK1303_AND_AMK[ MUL9((uint8_t) uI) ];
    m_IK1303.pAND_AMK1 = (uint8_t*) &IK1303_AND_AMK[ MUL9((((uint16_t) uI) >> 8)) ];

    m_IK1303.MOD = (uint8_t) (uI >> 24);
    m_IK1303.flag_FC = IK1303_uI_hi & 0x00FC;
    if (m_IK1303.flag_FC == 0) m_IK1303.T = 0;

    m_IK1303.key_xm = m_IK1303.key_x - 1;
  
  return IK1303_uI_hi;
}

inline usize IK1306_GoZero(void) {
    uint32_t uI = ROM.IK1306.instructions[m_IK1306.R[36] + 16 * m_IK1306.R[39]];
    const usize IK1306_uI_hi = uI >> 16;

    m_IK1306.pAND_AMK = (uint8_t*) &IK1306_AND_AMK[MUL9((uint8_t) uI)];
    m_IK1306.pAND_AMK1 = (uint8_t*) &IK1306_AND_AMK[MUL9((((uint16_t) uI) >> 8))];

    m_IK1306.MOD = (uint8_t) (uI >> 24);

  return IK1306_uI_hi;
}

void cycle(void) {
  mtick_t signal_I;
  const int MAX_CYCLE = (sergey_anvarov_hack_enable)? 280 : 560;
  for (int count = 1; count <= MAX_CYCLE; count++){
      signal_I = 0;

      const u8 IK1302_uI_hi = (u8) IK1302_GoZero();
      const u8 IK1303_uI_hi = (u8) IK1303_GoZero();
      const u8 IK1306_uI_hi = (u8) IK1306_GoZero();

      dbghexln(CORE61, "IK1302.IP = 0x", (u16) m_IK1302.R[36] + 16 * (u16) m_IK1302.R[39]);

      #ifdef out_dump
      dumpm(signal_I, count);
      #endif

          #pragma GCC unroll 99	//TODO: remove me
          for (auto _ : {0,1,2,3,4,5, 3,4,5,3,4,5, 3,4,5,3,4,5, 3,4,5,3,4,5, 6,7,8}) { CycleB(_); }	//0..26

          m_IK1302.pAND_AMK = m_IK1302.pAND_AMK1;
          m_IK1303.pAND_AMK = m_IK1303.pAND_AMK1;
          m_IK1306.pAND_AMK = m_IK1306.pAND_AMK1;

          #pragma GCC unroll 99	//TODO: remove me
          for (auto _ : {0,1,2, 3,4,5,6,7,8}) { CycleB(_); }	//27..35

      // signal == 36
      if (IK1302_uI_hi > 0x1f)
      {
          m_IK1302.R[37] = IK1302_uI_hi & 0xf;   // signal == 36
          m_IK1302.R[40] = IK1302_uI_hi >> 4;    // signal == 36
          m_IK1302.pAND_AMK  = (uint8_t*) &IK1302_AND_AMK[0x5f * 9];
      }
      else{
          m_IK1302.pAND_AMK  = (uint8_t*) &IK1302_AND_AMK[MUL9(IK1302_uI_hi)];
      }

      if (IK1303_uI_hi > 0x1f)
      {
          m_IK1303.R[37] = (IK1303_uI_hi) & 0xf;   // signal == 36
          m_IK1303.R[40] = (IK1303_uI_hi) >> 4;    // signal == 36
          m_IK1303.pAND_AMK  = (uint8_t*) &IK1303_AND_AMK[0x5f * 9];
      }
      else{
           m_IK1303.pAND_AMK  = (uint8_t*) &IK1303_AND_AMK[MUL9(IK1303_uI_hi)];
      }

      if (IK1306_uI_hi > 0x1f)
      {
          m_IK1306.R[37] = (IK1306_uI_hi) & 0xf;   // signal == 36
          m_IK1306.R[40] = (IK1306_uI_hi) >> 4;    // signal == 36
          m_IK1306.pAND_AMK  = (uint8_t*) &IK1306_AND_AMK[0x5f * 9];
      }
      else{
          m_IK1306.pAND_AMK  = (uint8_t*) &IK1306_AND_AMK[MUL9(IK1306_uI_hi)];
      }

          CycleB(0);   // 36
          CycleB(1);   // 37
          CycleB(2);   // 38
          CycleB(3);   // 39
          CycleB(4);
          CycleE(5);    // 41

          m_IK1302.pM += 42;
          m_IK1303.pM += 42;
          m_IK1306.pM += 42;
          if(m_IK1302.pM == END_ring_M/*&ringM[252+252+42+42+42]*/){
                  m_IK1302.pM = &ringM[0];
          }
          else if(m_IK1303.pM == END_ring_M/*&ringM[252+252+42+42+42]*/){
                  m_IK1303.pM = &ringM[0];
          }
          else if(m_IK1306.pM == END_ring_M/*&ringM[252+252+42+42+42]*/){
                   m_IK1306.pM = &ringM[0];
          }
  }
#ifdef out_dump
  step++;
#endif
}

void IK1302_Tick(mtick_t signal_I, usize J_signal_I)
{
 uint32_t  microinstruction;
 uint32_t  val, tmp;
 uint32_t  mi_hi;

// Вывод дампа отладочной информации 
  dbg(CORE61, "I:", signal_I, " J:",  J_signal_I, " 1302.R[");
  for(u8 R : m_IK1302.R) dbghex(CORE61, ".", R);
  dbg(CORE61, "]\n 1302.ST[");
  for(u8 ST : m_IK1302.ST) dbghex(CORE61, ".", ST);
  dbghexln(CORE61, "]\n pM = $", (usize) m_IK1302.pM - (usize) &ringM[0], " pAND_AMK = $", (usize) m_IK1302.pAND_AMK - (usize) IK1302_AND_AMK, " pAND_AMK1 = $", (usize) m_IK1302.pAND_AMK1 - (usize) IK1302_AND_AMK);
  dbghexln(CORE61, "AMK = ", m_IK1302.AMK);
  dbghex(CORE61, "FLAGS L ", m_IK1302.L);
  dbghex(CORE61, ":S ", m_IK1302.S);
  dbghex(CORE61, ":S1 ", m_IK1302.S1);
  dbghex(CORE61, ":P ", m_IK1302.P);
  dbghex(CORE61, ":T ", m_IK1302.T);
  dbghex(CORE61, ":MOD ", m_IK1302.MOD);
  dbghexln(CORE61, ":flag_FC ", m_IK1302.flag_FC);


    tmp = (uint8_t) m_IK1302.pAND_AMK[J_signal_I];
    if (tmp > 59 && m_IK1302.L == 0){ // Если AMK больше 59 (60,61,62,63), то пересчитываются (60,62,64,66) или (61,63,65,67) при L=0
       tmp++;
    }
    microinstruction = ROM.IK1302.microinstructions[tmp];
    m_IK1302.AMK = tmp;

    mi_hi = (microinstruction >> 16);
 //---------------------------------------------------------
    if((((microinstruction >> 24) & 0x03) == 0x2) || (((microinstruction >> 24) & 0x03) == 0x3)) {
        if (DIV3(signal_I) != m_IK1302.key_xm)
           m_IK1302.S1 |= m_IK1302.key_y;
    }
 //---------------------------------------------------------
    io_t alpha = 0;
    io_t gamma = 0;
    io_t sigma = 0;

    if((microinstruction & 0x7FFF) != 0){
        switch(IK1302_DCWA[tmp/*m_IK1302.AMK*/]) {
                case 0: alpha = 0; break;
                case 0x0002: alpha = m_IK1302.R[signal_I]; break;
                case 0x0004: alpha = m_IK1302.pM[signal_I]; break;
                case 0x0006: alpha = m_IK1302.ST[signal_I]; break;
                case 0x0008: alpha = ~m_IK1302.R[signal_I] & 0xf; break;
                case 0x000A: if (m_IK1302.L == 0) alpha = 0xa; else alpha = 0; break;
                case 0x000C: alpha = m_IK1302.S; break;
                case 0x000E: alpha = 4; break;
                case 0x0010: alpha = 0xf;
        }

        if((microinstruction & 0x0F80) != 0) {
          switch(microinstruction & 0x0F80) {
                case 0x0800: alpha += 1; break;
                case 0x0400: alpha += 6; break;
                case 0x0C00: alpha += (1|6); break;
                case 0x0080: alpha += m_IK1302.S; break;
                case 0x0100: alpha += (~m_IK1302.S & 0xf); break;
                case 0x0200: alpha += m_IK1302.S1; break;
                case 0x0180: alpha += 0xf; break;
                case 0x0280: alpha += (m_IK1302.S | m_IK1302.S1); break;
          }
        }
   //---------------------------------------------------------
        if (m_IK1302.flag_FC > 0){
                if (m_IK1302.key_y == 0) m_IK1302.T = 0;
        } else {
                m_IK1302.displayed = 1;
                val = DIV3(signal_I);
                if((val == m_IK1302.key_xm) && (m_IK1302.key_y != 0)){
                                m_IK1302.S1 = m_IK1302.key_y;
                                m_IK1302.T = 1;
                }
                if((val < 12) && (m_IK1302.L != 0)) m_IK1302.comma = val;
        }
   //---------------------------------------------------------
        if((microinstruction & 0x4000) != 0) gamma = m_IK1302.T ^ 1; else gamma = 0;
        if((microinstruction & 0x2000) != 0) gamma |= m_IK1302.L ^ 1;
        if((microinstruction & 0x1000) != 0) gamma |= m_IK1302.L;

        alpha += gamma;
        sigma = alpha & 0xf;
        m_IK1302.P = alpha >> 4;
    } else {
   //---------------------------------------------------------
        if (m_IK1302.flag_FC > 0){
                if (m_IK1302.key_y == 0) m_IK1302.T = 0;
        } else {
                m_IK1302.displayed = 1;
                val = DIV3(signal_I);
                if((val == m_IK1302.key_xm) && (m_IK1302.key_y != 0)){
                                m_IK1302.S1 = m_IK1302.key_y;
                                m_IK1302.T = 1;
                }
                if((val < 12) && (m_IK1302.L != 0)) m_IK1302.comma = val;
        }
    //---------------------------------------------------------
        sigma = 0;
        m_IK1302.P = 0;
    }
#ifdef out_dump
printf("AMK %4.4X, microinstruction: %8.8X, MOD %u, S %u, S1 %u, sigma %u\n", m_IK1302.AMK, microinstruction, IK1302_MOD, IK1302_S, IK1302_S1, sigma);
#endif
//---------------------------------------------------------
    if (m_IK1302.MOD == 0 || signal_I >= 36) {
        tmp = IK1302_DCW[tmp/*m_IK1302.AMK*/];
        if(tmp != 0){
          switch (tmp) {
            case 1: 
                dbgln(CORE61, "R[", signal_I, "] = R[", MOD42(signal_I + 3));
                m_IK1302.R[signal_I] = m_IK1302.R[MOD42(signal_I + 3)]; 
              break;
            case 2: m_IK1302.R[signal_I] = sigma; break;
            case 3: m_IK1302.R[signal_I] = m_IK1302.S; break;
            case 4: m_IK1302.R[signal_I] = m_IK1302.R[signal_I] | m_IK1302.S | sigma; break;
            case 5: m_IK1302.R[signal_I] = m_IK1302.S | sigma; break;
            case 6: m_IK1302.R[signal_I] = m_IK1302.R[signal_I] | m_IK1302.S; break;
            case 7: m_IK1302.R[signal_I] = m_IK1302.R[signal_I] | sigma;
          }
        }

        if ((mi_hi & 0x0004) !=0)    m_IK1302.R[MOD42(signal_I + 41)] = sigma;
        if ((mi_hi & 0x0008) !=0)    m_IK1302.R[MOD42(signal_I + 40)] = sigma;
    }
    if ((mi_hi & 0x0020) !=0)        m_IK1302.L = m_IK1302.P & 1;
    if ((mi_hi & 0x0010) !=0)        m_IK1302.pM[signal_I] = m_IK1302.S;
//---------------------------------------------------------

        if((mi_hi & 0x0040) == 0){
         // 6 bit == 0, может быть 7 бит не равен?
          if((mi_hi & 0x0080) != 0)  m_IK1302.S = sigma; // 7 bit == 1
        } else {
         // 6 bit == 1, может быть 7 бит тоже равен?
                m_IK1302.S = m_IK1302.S1;
          if((mi_hi & 0x0080) != 0) m_IK1302.S |= sigma;
        }

        // 6 bit == 0, нам пофиг на состояние 7 бита
        if((mi_hi & 0x0100) != 0){
         // 6 bit == 1, может быть 7 бит тоже равен?
          if((mi_hi & 0x0200) != 0) m_IK1302.S1 |= sigma; else m_IK1302.S1 = sigma;
        }
//----------------------------------------------------------
    mi_hi = mi_hi & 0x0C00;
    if(mi_hi != 0){
          if(mi_hi == 0x0400) {
                    m_IK1302.ST[MOD42(signal_I + 2)] = m_IK1302.ST[MOD42(signal_I + 1)];
                    m_IK1302.ST[MOD42(signal_I + 1)] = m_IK1302.ST[signal_I];
                    m_IK1302.ST[signal_I] = sigma;
          } else if(mi_hi == 0x0800) {
                    tmp = m_IK1302.ST[signal_I];
                    m_IK1302.ST[signal_I] = m_IK1302.ST[MOD42(signal_I + 1)];
                    m_IK1302.ST[MOD42(signal_I + 1)] = m_IK1302.ST[MOD42(signal_I + 2)];
                    m_IK1302.ST[MOD42(signal_I + 2)] = tmp;
          }
    }
}

//uint8_t IK1302_DCWA[68];
void IK1302_Clear(void) {
    m_IK1302.pM = (uint8_t*) IK1302_M_START;
    memset(m_IK1302.R, 0, sizeof(m_IK1302.R));
    memset(m_IK1302.ST, 0, sizeof(m_IK1302.ST));
    m_IK1302.AMK = 0;
    m_IK1302.key_y = 0;
    m_IK1302.key_x = 0;
    m_IK1302.comma = 0;
    m_IK1302.S = 0;
    m_IK1302.S1 = 0;
    m_IK1302.L = 0;

    m_IK1302.T = 0;
    m_IK1302.P = 0;
    m_IK1302.MOD = 0;
    m_IK1302.pAND_AMK = (uint8_t*) &IK1302_AND_AMK[0];
    m_IK1302.pAND_AMK1 = (uint8_t*) &IK1302_AND_AMK[0];
}

void IK1303_Clear(void)
{
    m_IK1303.pM = (uint8_t*)IK1303_M_START;
    memset(m_IK1303.R, 0, sizeof(m_IK1303.R));
    memset(m_IK1303.ST, 0, sizeof(m_IK1303.ST));
    m_IK1303.S = 0;
    m_IK1303.S1 = 0;
    m_IK1303.L = 0;
    m_IK1303.P = 0;
    m_IK1303.T = 0;
    m_IK1303.key_x = 0;
    m_IK1303.key_y = 0;
    m_IK1303.comma = 0;
    m_IK1303.AMK = 0;
    m_IK1303.MOD = 0;
    m_IK1303.pAND_AMK   = (uint8_t*) &IK1303_AND_AMK[0];
    m_IK1303.pAND_AMK1  = (uint8_t*) &IK1303_AND_AMK[0];
}

void IK1303_Tick(mtick_t signal_I, usize J_signal_I)
{
 uint32_t tmp;
 uint32_t microinstruction;
 uint32_t mi_hi;

 tmp = (uint8_t) m_IK1303.pAND_AMK[J_signal_I];
 if (tmp > 59 && m_IK1303.L == 0){ // Если AMK больше 59 (60,61,62,63), то пересчитываются (60,62,64,66) или (61,63,65,67) при L=0
      tmp++;
 }

 microinstruction = ROM.IK1303.microinstructions[tmp];
 m_IK1303.AMK = tmp;

 mi_hi = (microinstruction >> 16);
//---------------------------------------------------------
 if((((microinstruction >> 24) & 0x03) == 0x2) || (((microinstruction >> 24) & 0x03) == 0x3)) {
     if (DIV3(signal_I) != m_IK1303.key_xm) {
         // TODO remove if (m_IK1303.key_y > 0)
         m_IK1303.S1 |= m_IK1303.key_y;
     }
 }
//---------------------------------------------------------
   io_t alpha = 0;
   io_t gamma = 0;
   io_t sigma = 0;
   if((microinstruction & 0x7FFF) != 0){

        switch(microinstruction & 0x007F){
                case 0x0001: alpha = m_IK1303.R[signal_I]; break;
                case 0x0002: alpha = m_IK1303.pM[signal_I]; break;
                case 0x0004: alpha = m_IK1303.ST[signal_I]; break;
                case 0x0008: alpha = ~m_IK1303.R[signal_I] & 0xf; break;
                case 0x0009: alpha = 0xf; break;
                case 0x0010: if (m_IK1303.L == 0) alpha = 0xa; else alpha = 0; break;
                case 0x0020: alpha = m_IK1303.S; break;
                case 0x0040: alpha = 4; break;
                case 0: alpha = 0;
        }

        if((microinstruction & 0x0F80) != 0){
          switch(microinstruction & 0x0F80){
                case 0x0800: alpha += 1; break;
                case 0x0400: alpha += 6; break;
                case 0x0C00: alpha += 1|6; break;
                case 0x0080: alpha += m_IK1303.S; break;
                case 0x0100: alpha += ~m_IK1303.S & 0xf; break;
                case 0x0200: alpha += m_IK1303.S1; break;
                case 0x0180: alpha += 0xf; break;
                case 0x0280: alpha += m_IK1303.S | m_IK1303.S1; break;
                case 0x0500: alpha += 6 | (~m_IK1303.S & 0xf); break;
          }
    }
   //---------------------------------------------------------
        if (m_IK1303.flag_FC > 0){
                if (m_IK1303.key_y == 0) m_IK1303.T = 0;
        }
        else{
                tmp = DIV3(signal_I);
                if (tmp == m_IK1303.key_xm)
                        if (m_IK1303.key_y > 0) {
                                m_IK1303.S1 = m_IK1303.key_y;
                                m_IK1303.T = 1;
                        }
                if (tmp < 12) if (m_IK1303.L > 0)  m_IK1303.comma = tmp;
        }
   //---------------------------------------------------------
        if((microinstruction & 0x4000) != 0) gamma = m_IK1303.T ^ 1; else gamma = 0;
        if((microinstruction & 0x2000) != 0) gamma |= m_IK1303.L ^ 1;
        if((microinstruction & 0x1000) != 0) gamma |= m_IK1303.L;

        alpha +=gamma;
        sigma = alpha & 0xf;
        m_IK1303.P = alpha >> 4;
   }
   else{
     //---------------------------------------------------------
        if (m_IK1303.flag_FC > 0){
                if (m_IK1303.key_y == 0) m_IK1303.T = 0;
        }
        else{
                tmp = DIV3(signal_I);
                if (tmp == m_IK1303.key_xm)
                        if (m_IK1303.key_y > 0) {
                                m_IK1303.S1 = m_IK1303.key_y;
                                m_IK1303.T = 1;
                        }
                if (tmp < 12) if (m_IK1303.L > 0)  m_IK1303.comma = tmp;
        }
   //---------------------------------------------------------
        sigma = 0;
        m_IK1303.P = 0;
   }
#ifdef out_dump
printf("AMK %4.4X, microinstruction: %8.8X, MOD %u, S %u, S1 %u, sigma %u\n", m_IK1303.AMK, microinstruction, m_IK1303.MOD, m_IK1303.S, m_IK1303.S1, sigma);
#endif
//---------------------------------------------------------
    if (m_IK1303.MOD == 0 || signal_I >= 36)
    {
        tmp = IK1303_DCW[m_IK1303.AMK];
                if(tmp != 0){
          switch (tmp)
          {
            case 1: m_IK1303.R[signal_I] = m_IK1303.R[MOD42(signal_I + 3)]; break;
            case 2: m_IK1303.R[signal_I] = sigma; break;
            case 3: m_IK1303.R[signal_I] = m_IK1303.S; break;
            case 4: m_IK1303.R[signal_I] = m_IK1303.R[signal_I] | m_IK1303.S | sigma; break;
            case 5: m_IK1303.R[signal_I] = m_IK1303.S | sigma; break;
            case 6: m_IK1303.R[signal_I] = m_IK1303.R[signal_I] | m_IK1303.S; break;
            case 7: m_IK1303.R[signal_I] = m_IK1303.R[signal_I] | sigma; break;
          }
                }

        if ((mi_hi & 0x0004) !=0)    m_IK1303.R[MOD42(signal_I + 41)] = sigma;
        if ((mi_hi & 0x0008) !=0)    m_IK1303.R[MOD42(signal_I + 40)] = sigma;
    }
    if ((mi_hi & 0x0020) !=0)        m_IK1303.L = m_IK1303.P & 1;
    if ((mi_hi & 0x0010) !=0)        m_IK1303.pM[signal_I] = m_IK1303.S;
//---------------------------------------------------------

        if((mi_hi & 0x0040) == 0){
         // 6 bit == 0, может быть 7 бит не равен?
          if((mi_hi & 0x0080) != 0)  m_IK1303.S = sigma; // 7 bit == 1
        }
        else{
         // 6 bit == 1, может быть 7 бит тоже равен?
          m_IK1303.S = m_IK1303.S1;
          if((mi_hi & 0x0080) != 0) m_IK1303.S |= sigma;
        }

         // 6 bit == 0, нам пофиг на состояние 7 бита
        if((mi_hi & 0x0100) != 0){
         // 6 bit == 1, может быть 7 бит тоже равен?
          if((mi_hi & 0x0200) != 0) m_IK1303.S1 |= sigma; else m_IK1303.S1 = sigma;
        }
//----------------------------------------------------------
    mi_hi = mi_hi & 0x0C00;
    if(mi_hi != 0){
          if(mi_hi == 0x0400){
                    m_IK1303.ST[MOD42(signal_I + 2)] = m_IK1303.ST[MOD42(signal_I + 1)];
                    m_IK1303.ST[MOD42(signal_I + 1)] = m_IK1303.ST[signal_I];
                    m_IK1303.ST[signal_I] = sigma;
          }
          else if(mi_hi == 0x0800){
                    tmp = m_IK1303.ST[signal_I];
                    m_IK1303.ST[signal_I] = m_IK1303.ST[MOD42(signal_I + 1)];
                    m_IK1303.ST[MOD42(signal_I + 1)] = m_IK1303.ST[MOD42(signal_I + 2)];
                    m_IK1303.ST[MOD42(signal_I + 2)] = tmp;
          }
    }
}

void IK1306_Clear(void)
{
    m_IK1306.pM = (uint8_t*)IK1306_M_START;
    memset(m_IK1306.R, 0, sizeof(m_IK1306.R));
    memset(m_IK1306.ST, 0, sizeof(m_IK1306.ST));
    m_IK1306.S = 0;
    m_IK1306.S1 = 0;
    m_IK1306.L = 0;
    m_IK1306.P = 0;
    m_IK1306.AMK = 0;
    m_IK1306.MOD = 0;
    m_IK1306.pAND_AMK   = (uint8_t*) &IK1306_AND_AMK[0];
    m_IK1306.pAND_AMK1  = (uint8_t*) &IK1306_AND_AMK[0];
}

void IK1306_Tick(mtick_t signal_I, usize J_signal_I)
{
    uint32_t tmp, mi_hi;
    uint32_t microinstruction;

    tmp = (uint8_t) m_IK1306.pAND_AMK[J_signal_I];            //    AMK = AND_AMK[ASPx9 + J_signal_I];
    if (tmp > 59 && m_IK1306.L == 0){                         // Если AMK больше 59 (60,61,62,63), то пересчитываются (60,62,64,66) или (61,63,65,67) при L=0
        tmp++;
    }
    microinstruction = ROM.IK1306.microinstructions[tmp];
    m_IK1306.AMK = tmp;


    mi_hi = (microinstruction >> 16);
//---------------------------------------------------------
    io_t alpha = 0;
    io_t gamma = 0;
    io_t sigma = 0;
    if((microinstruction & 0x3FFF) != 0){
        switch(microinstruction & 0x007F) {
                case 0x0001: alpha = m_IK1306.R[signal_I]; break;
                case 0x0002: alpha = m_IK1306.pM[signal_I]; break;
                case 0x0004: alpha = m_IK1306.ST[signal_I]; break;
                case 0x0005: alpha = m_IK1306.ST[signal_I] | m_IK1306.R[signal_I]; break;
                case 0x0008: alpha = ~m_IK1306.R[signal_I] & 0xf; break;
                case 0x0009: alpha = 0xf; break;
                case 0x0010: if(m_IK1306.L == 0) alpha = 0xa; else alpha = 0; break;
                case 0x0020: alpha = m_IK1306.S; break;
                case 0x0021: alpha = m_IK1306.S | m_IK1306.R[signal_I]; break;
                case 0x0028: alpha = m_IK1306.S | (~m_IK1306.R[signal_I] & 0xf); break;
                case 0x0040: alpha = 4; break;
                case 0: alpha = 0;
        }

        if((microinstruction & 0x0F80) != 0) {
           switch(microinstruction & 0x0F80) {
             case 0x0800: alpha += 1; break;
             case 0x0400: alpha += 6; break;
             case 0x0C00: alpha += 1|6; break;
             case 0x0080: alpha += m_IK1306.S; break;
             case 0x0100: alpha += ~m_IK1306.S & 0xf; break;
             case 0x0200: alpha += m_IK1306.S1; break;
             case 0x0180: alpha += m_IK1306.S | (~m_IK1306.S & 0xf); break;
           }
        }
 //---------------------------------------------------------
     if((microinstruction & 0x2000) != 0) gamma = m_IK1306.L ^ 1; else gamma=0;
     if((microinstruction & 0x1000) != 0) gamma |= m_IK1306.L;

     alpha += gamma;
     sigma = alpha & 0xf;
     m_IK1306.P = alpha >> 4;
    }
    else{
            sigma = 0;
           m_IK1306.P = 0;
    }
#ifdef out_dump
printf("AMK %4.4X, microinstruction: %8.8X, MOD %u, S %u, S1 %u, sigma %u\n", m_IK1306.AMK, microinstruction, IK1306_MOD, IK1306_S, IK1306_S1, sigma);
#endif
//---------------------------------------------------------
    if (m_IK1306.MOD == 0 || signal_I >= 36)
    {
        tmp = IK1306_DCW[m_IK1306.AMK];
        if(tmp != 0){
          switch (tmp){
            case 1: m_IK1306.R[signal_I] = m_IK1306.R[MOD42(signal_I + 3)]; break;
            case 2: m_IK1306.R[signal_I] = sigma; break;
            case 3: m_IK1306.R[signal_I] = m_IK1306.S; break;
            case 4: m_IK1306.R[signal_I] = m_IK1306.R[signal_I] | m_IK1306.S | sigma; break;
            case 5: m_IK1306.R[signal_I] = m_IK1306.S | sigma; break;
            case 6: m_IK1306.R[signal_I] = m_IK1306.R[signal_I] | m_IK1306.S; break;
            case 7: m_IK1306.R[signal_I] = m_IK1306.R[signal_I] | sigma; break;
          }
        }

        if ((mi_hi & 0x0004) !=0)    m_IK1306.R[MOD42(signal_I + 41)] = sigma;
        if ((mi_hi & 0x0008) !=0)    m_IK1306.R[MOD42(signal_I + 40)] = sigma;
    }
    if ((mi_hi & 0x0020) !=0)        m_IK1306.L = m_IK1306.P & 1;
    if ((mi_hi & 0x0010) !=0)        m_IK1306.pM[signal_I] = m_IK1306.S;
//---------------------------------------------------------

    if((mi_hi & 0x0040) == 0){
      // 6 bit == 0, может быть 7 бит не равен?
      if((mi_hi & 0x0080) != 0)  m_IK1306.S = sigma; // 7 bit == 1
    }
    else{
      // 6 bit == 1, может быть 7 бит тоже равен?
      m_IK1306.S = m_IK1306.S1;
      if((mi_hi & 0x0080) != 0) m_IK1306.S |= sigma;
    }

    // 6 bit == 0, нам пофиг на состояние 7 бита
    if((mi_hi & 0x0100) != 0){
      // 6 bit == 1, может быть 7 бит тоже равен?
      if((mi_hi & 0x0200) != 0) m_IK1306.S1 |= sigma; else m_IK1306.S1 = sigma;
    }
//----------------------------------------------------------
    mi_hi = mi_hi & 0x0C00;
    if(mi_hi != 0){
          if(mi_hi == 0x0400){
                    m_IK1306.ST[MOD42(signal_I + 2)] = m_IK1306.ST[MOD42(signal_I + 1)];
                    m_IK1306.ST[MOD42(signal_I + 1)] = m_IK1306.ST[signal_I];
                    m_IK1306.ST[signal_I] = sigma;
          }
          else if(mi_hi == 0x0800){
                    tmp = m_IK1306.ST[signal_I];
                    m_IK1306.ST[signal_I] = m_IK1306.ST[MOD42(signal_I + 1)];
                    m_IK1306.ST[MOD42(signal_I + 1)] = m_IK1306.ST[MOD42(signal_I + 2)];
                    m_IK1306.ST[MOD42(signal_I + 2)] = tmp;
          }
    }
}

/**
 * mk61emu
 */

void MK61Emu_Cleanup() {
    for(usize i=0; i < (42+41); i++) mod42_table[i] = i%42;
    memset(&ringM,0,sizeof(ringM));
    IK1302_Clear();
    IK1303_Clear();
    IK1306_Clear();
}

void MK61Emu_SetKeyPress(const int key1, const int key2) {
    m_IK1302.key_x = key1;
    m_IK1302.key_y = key2;
}

void MK61Emu_SetDisplayed(uint32_t value) {
    m_IK1302.displayed = value;
}

uint32_t MK61Emu_GetDisplayed(void) {
    return m_IK1302.displayed;
}

inline uint32_t MK61Emu_GetComma(void) {
    return m_IK1302.comma;
}

bool MK61Emu_IsRunning(void) {
    if (m_IK1302.comma == 11) {
        return true;
    }
    return false;
}

void MK61Emu_SetAngleUnit(AngleUnit angle) {
    m_emu.m_angle_unit = angle;
}

AngleUnit MK61Emu_GetAngleUnit(void) {
    return m_emu.m_angle_unit;
}

/*

void  read_Y(char* buffer, const char* display_symbols) { // считывает в буфер регистра стека
  bool lider_zero = true;
  for(int i=580-33+24; i >= 580-33; i-=3) {
    const u8 digit = ringM[i];
    if(digit == 0 && lider_zero) {
      lider_zero = false;
    } else {
      *buffer++ = display_symbols[digit];
    }
  }
}

void    MK61Emu_SetStackStr(StackRegister stack_reg, char sign, char mantissa[8], isize pow) {
  isize addr = (isize) stack_reg;
  if(pow < 0) {
    pow += 100;
    ringM[addr] = 9;
  } else {
    ringM[addr] = 0;
  }
  addr -= 3;
  ringM[addr] = pow / 10;
  addr -= 3;
  ringM[addr] = pow % 10;
  addr -= 3;
  ringM[addr] = (sign == '-')? 9 : 0;

  for(isize i=0; i<8; i++) {
    addr -= 3;
    ringM[addr] = mantissa[i] - '0';
  }
}*/

void write_stack_register(stack reg, char sign, char cmantissa[8], isize pow) {
  isize addr = (isize) reg + 1;
  // mantissa convert
  for(isize i=7; i >= 0; i--) {
    ringM[addr] = cmantissa[i] - '0';
    addr += 3;
  }
  // pow convert
  ringM[addr] = (sign == '-')? 9 : 0;
  if(pow < 0) {
    pow += 100;
    ringM[addr + 9] = 9;
  } else {
    ringM[addr + 9] = 0;
  }
  ringM[addr + 6] = pow / 10;
  ringM[addr + 3] = pow % 10;
}

/*
 buffer 012345678901234
        -1.2345678 -99
*/
const char* read_stack_register(stack reg, char cvalue[15], const char* symbols_set) {
  // mantissa convert
  usize i = (usize) reg + 1;
  isize pos = 9;
  do {
    if(pos == 2) cvalue[pos--] = '.';
    cvalue[pos--] = symbols_set[ringM[i]];
    i += 3;
  } while(pos > 0);
  cvalue[0] = (ringM[i] == 9)? '-' : ' ';
  // pow convert
  cvalue[10] = ' ';
  const usize powl = ringM[i + 3];
  const usize powh = ringM[i + 6];
  if(ringM[i + 9] == 9) {
    cvalue[11] = '-';
    const usize pow = 100 - (powh*10 + powl);
    cvalue[12] = symbols_set[pow / 10];
    cvalue[13] = symbols_set[pow % 10];
  } else {
    cvalue[11] = ' ';
    cvalue[12] = symbols_set[powh];
    cvalue[13] = symbols_set[powl];
  }

  return &cvalue[0];
}
/*
const char* MK61Emu_GetStackStr(StackRegister stack_reg, const char* symbols_set) {
    char *reg_stack;
    if (stack_reg == REG_Y) {
        reg_stack = m_emu.m_stack_y_str;
    }
    else {
        reg_stack = m_emu.m_stack_z_str;
    }

    memset(reg_stack, 0, INDICATOR_STRING_LENGTH);
    memset(reg_stack, ' ', INDICATOR_STRING_LENGTH - 3);

     // Формат числа:
    uint16_t tail_address = (uint16_t)stack_reg; // Смещение последнего байта экспоненты

    // Собираем порядок числа
    int16_t exp_value = ringM[tail_address - 3] * 10 + ringM[tail_address - 6];
    if (ringM[tail_address] == 9) {
        exp_value = -(100 - exp_value);
    }

    // Собираем мантиссу
    int i = 0;
    while (ringM[tail_address - 33 + i * 3] == 0) {
        if (exp_value == 7 - i || i == 7) {
            break;
        }
        i++;
    }

    uint8_t digits[8];
    memset(digits, 0, 8);
    int digits_len = 0;
    int j = 8 - i;
    while (i < 8)
    {
        digits[--j] = ringM[tail_address - 33 + i * 3];
        digits_len++;
        i++;
    }

    reg_stack[0] = (ringM[tail_address - 9] == 9) ? '-' : ' ';

    bool has_point = false;
    j = 1;
    for (i = 0; i < digits_len; i++) {
        reg_stack[j++] = symbols_set[digits[i]];
        if ((i == 0 && (exp_value < 0 || exp_value > 7)) || (i == exp_value)) {
            reg_stack[j++] = '.';
            has_point = true;
        }
    }

    if (!has_point) {
        reg_stack[i] = '.';
    }

    if (exp_value < 0 || exp_value > 7) {
        if (exp_value < 0) {
            reg_stack[10] = '-';
            exp_value = -exp_value;
        }

        reg_stack[11] = symbols_set[exp_value / 10];
        reg_stack[12] = symbols_set[exp_value % 10];
    }
    else {
        memset((reg_stack + 11), ' ', 3);
    }

    return reg_stack;
}*/


//                                           mantisa                   |    pow
//                                       0   1   2   3   4  5  6  7  8   9  10  11
static const usize indicator_pos[12] = {24, 21, 18, 15, 12, 9, 6, 3, 0, 33, 30, 27};
namespace core_61 {

static  usize   backstep_comma_position;

void step(void) {
    m_IK1303.key_y = 1;
    m_IK1303.key_x = m_emu.m_angle_unit;
    ::cycle();
    m_IK1302.key_x = 0;
    m_IK1302.key_y = 0;
}

void enable(void) {
    MK61Emu_Cleanup();
    //MK61Emu_SetAngleUnit(RADIAN);
    core_61::clear_displayed();
    backstep_comma_position = core_61::comma_position();
    step();
}

bool  update_indicator(char* buffer, const char* display_symbols) { // возращает false - есть изменения в дисплейной строке/ true - нет изменений
  const isize  comma_pos = 9 - m_IK1302.comma + 1;
  bool match = true;

  isize i = 0;
  while(i < comma_pos) {
    const char read_char = display_symbols[ m_IK1302.R[ indicator_pos[i++] ] ];

    match = (*buffer == read_char);
    if(match) {
      buffer++;
    } else {
      *buffer++ = read_char;
      while(i < comma_pos) {
        const char read_char = display_symbols[ m_IK1302.R[ indicator_pos[i++] ] ];
        *buffer++ = read_char; 
      }
      break;
    }
  }

  if(i == comma_pos) *buffer++ = '.';

  while(i < 12) {
    const char read_char = display_symbols[ m_IK1302.R[ indicator_pos[i++] ] ];

    match &= (*buffer == read_char);
    if(match) {
      buffer++;
    } else {
      *buffer++ = read_char;
      while(i < 12) {
        const char read_char = display_symbols[ m_IK1302.R[ indicator_pos[i++] ] ];
        *buffer++ = read_char; 
      }
      break;
    }
  }
  *buffer = 0;

  return match;
}

}
//                   1--------12--------23--- 
//          123456789012345678901234567890123
//   nReg*42
//     ----7--6--5--4--3--2--1--0--S--1--0--s
//   { sign_num|sign_pow|len, abs(pow), mantissa... }

u8* MK61Emu_UnpackRegster(u8 nReg, u8 *pack_number) {
  //const u8 nReg = *pack_number++;
  const i8 sign = *pack_number & 0b11000000;
  const u8 len  = *pack_number++ & 0b00111111;
  const u8 pow  = *pack_number++;
  const int cnt_zero = len * 2;
  int   addr = nReg*42 + 21;
  u8    two_digits = 0;

      ringM[addr + 3] = (sign < 0)? 9 : 0;
      if((sign & 0b01000000) != 0) {
        ringM[addr + 3*4] = 9;
      } else {
        ringM[addr + 3*4] = 0;
      }

      for(int j = 0; j < 8; j++){
        if(j >= cnt_zero) {
          ringM[addr] = 0; 
        } else {
          if ((j & 1) == 0) { // четные цифры
            two_digits = *pack_number++;
            ringM[addr] = two_digits >> 4;
          } else { // нечетные цифры
            ringM[addr] = two_digits & 0xF; 
          }
        }
        addr -= 3;
      }  

    ringM[addr + 27 + 3] = pow & 0xF; 
    ringM[addr + 30 + 3] = pow >> 4;
    
  return pack_number;
}

void    MK61Emu_WriteRegister(int nReg, char* buffer) {
  int addr = nReg*42 + 21;

    for(int j = 3; j < 11; j++){
      ringM[addr] = *buffer++ - '0'; 
      addr -= 3;
    }  

    buffer++;
    ringM[addr+30+3] = *buffer++ - '0'; 
    ringM[addr+27+3] = *buffer++ - '0'; 
}
/*
char    digit_as_MK61(u8 digit_hex) {
  static const char MK61_HEX_DIGITS[6] = {'-','L','C','\303','E',' '};
  if(digit_hex <= 9) 
    return ('0' | digit_hex);
  else if(digit_hex > 9 && digit_hex <= 0xF)
    return MK61_HEX_DIGITS[digit_hex - 10];
  else
    return '?';
}
*/
//      0       1      2     3
// 24, 21, 18, 15, 12, 9, 6, 3, 0 ::: 33, 30, 27
void    MK61Emu_ReadRegister(int nReg, char* buffer, const char* display_symbols) {
  int addr = nReg*42 + 21;
  const u8 sign_pow_tetra = ringM[addr + 3*4];
  const bool sign_pow = ringM[addr + 3*4];
  const bool sign_val = ringM[addr + 3];

  *buffer++ = (sign_val)? '-' : ' ';

  dbghex(MK61E, (isize) ringM[addr+3], ','); 

  for(int j = 3; j < 11; j++){
    *buffer++ = display_symbols[ringM[addr]]; 
    dbghex(MK61E, (isize) ringM[addr], ',');
    if(j == 3) *buffer++ = '.';
    addr -= 3;
  }  
  *buffer++ = ' ';

  dbghex(MK61E, 'E', (isize) ringM[sign_pow_tetra], ',');
  dbghex(MK61E, (isize) ringM[addr+30+3], ','); 
  dbghex(MK61E, (isize) ringM[addr+27+3], '|'); 

  if(sign_pow != 0) {
    *buffer++ = '-';
    const usize pow = 100 - ringM[addr+30+3]*10 - ringM[addr+27+3];
    *buffer++ = display_symbols[pow / 10]; 
    *buffer++ = display_symbols[pow % 10]; 
  } else {
    *buffer++ = ' ';
    *buffer++ = display_symbols[ringM[addr+30+3]]; 
    *buffer++ = display_symbols[ringM[addr+27+3]]; 
  }
  *buffer = 0x00;
}

usize   MK61Emu_Read_R_mantissa(usize nReg) {
  usize addr = nReg*42 + 21;
  usize value = 0;
  for(usize j = 3; j < 11; j++){
    value = (value * 10) + ringM[addr]; 
    addr -= 3;
  } 
  
  return value;
}

usize MK61Emu_Read_X_as_byte(void) {
  isize num = 0;
    for(isize i = 21; i >= 12 ; i -= 3) {
      const int digit = m_IK1302.R[i];
      if(digit <= 9) num = num*10 + digit; else break;
      if(num > 256) break;
    }

  return num;
}

uint8_t MK61Emu_GetCode(int addr){
    return (ringM[addr]<<4)|(ringM[addr-3]);
}

void MK61Emu_SetCode(int addr, uint8_t data) {
    ringM[addr] = data >> 4;
    ringM[addr-3] = data & 0x0F;
}

void  MK61Emu_GetCodePage(uint8_t* page) {
  for(usize i = 41; i < SIZE_RING_M/*672*/; i+=42) {
    *page++ = MK61Emu_GetCode(i);
    usize addr = i - 36;
    while(addr < i) {
          *page++ = MK61Emu_GetCode(addr);
          addr += 6;
    }
  }
}

void  MK61Emu_ClearCodePage(void) {
    for(usize i = 41; i < SIZE_RING_M/*672*/; i+=42) {
      MK61Emu_SetCode(i, 0);
      for(usize addr=i-36; addr < i; addr+=6) {
        MK61Emu_SetCode(addr, 0);
      }
    }
}

void MK61Emu_get_1302_R(char* buff) {
  for(int i=0; i < IK13_MTICK_COUNT; i++) {
    const uint8_t nibl = m_IK1302.R[i];
    buff[i] = (char) (nibl < 10)? nibl + '0' : nibl - 10 + 'A';
  }
  buff[42] = 0;
}

int MK61Emu_GetDisplayReg(void) {
  int num = 0;
    for(int i = 21; i >= 0 ; i -= 3) {
      const int digit = m_IK1302.R[i];
      #ifdef DEBUG
        Serial.print(digit); Serial.print(",");
      #endif
      if(digit <= 9) num = num*10 + digit; else break;
    }
    #ifdef DEBUG
      Serial.println(num);
    #endif

  return num;
}

const char* MK61Emu_GetIndicatorStr(const char* display_symbols) {
    uint16_t i = 0;

    memset(m_emu.m_indicator_str, 0, 15);
    memset(m_emu.m_indicator_str, ' ', 12);

    for (i = 0; i < 9; i++) {
        m_emu.m_indicator_str[i] = display_symbols[m_IK1302.R[(8 - i) * 3]];
    }
    for (i = 0; i < 3; i++) {
        m_emu.m_indicator_str[i + 10] = display_symbols[m_IK1302.R[(11 - i) * 3]];
    }

    int comma_pos = 9 - m_IK1302.comma + 1;
    for (i = 13; i >= comma_pos; i--) {
        m_emu.m_indicator_str[i] = m_emu.m_indicator_str[i - 1];
    }

    m_emu.m_indicator_str[comma_pos] = ',';
    return m_emu.m_indicator_str;
}
